// <auto-generated>
//
// This file was automatically generated by Interoptopus.
//
// Library:      proto_benchy
// Hash:         0xd7797cbe8a8e66ad
// Namespace:    wire
// Builder:      interoptopus_backend_csharp (0.15.0-alpha.12)
//
// Do not edit this file manually.
//
// </auto-generated>

#pragma warning disable 0105
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Runtime.CompilerServices;
using Gen.Ffi;
using Gen.ForCSharp;
using Gen.Wire;
#pragma warning restore 0105

namespace Gen.Wire
{
    public static partial class Interop
    {
        public const string NativeLib = "proto_benchy";

        static Interop()
        {
        }



        /// Main benchmark entry point for wire based interop.
        [LibraryImport(NativeLib, EntryPoint = "WireRustClient")]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial WireOfWOutputs WireRustClient(WireOfWInput wire_input);


    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WConfiguration
    {
        /// 
        public bool is_ok_response;
        /// 
        public String host;
        /// 
        public ulong response_size;

        /// <summary>Empty constructor</summary>
        public WConfiguration() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WConfiguration(bool is_ok_response, String host, ulong response_size)
        {
            this.is_ok_response = is_ok_response;
            this.host = host;
            this.response_size = response_size;
        }

        public override string ToString()
        {
            return "WConfiguration { is_ok_response = " + is_ok_response + ", host = " + host + ", response_size = " + response_size + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WConfiguration object
        /// </summary>
        public static WConfiguration Deserialize(BinaryReader reader)
        {
            return new WConfiguration {
                
            is_ok_response = reader.ReadByte() != 0,


                host = WireInterop.DeserializeString(reader), /* string */
                
            response_size = reader.ReadUInt64(),


            };

        }

        /// <summary>
        /// Serialize a WConfiguration object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {


            writer.Write(this.is_ok_response);


            this.host.Serialize(writer); /* string */

            writer.Write(this.response_size);



        }

        /// <summary>
        /// Calculate the size needed to serialize a WConfiguration object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            1 /* primitive */

                + 
            Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(this.host ?? "") /* string */

                + 
            8 /* primitive */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WConfiguration to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWConfigurationExtensions
    {
        public static void SerializeWConfiguration(BinaryWriter writer, WConfiguration item)
        {
            item.Serialize(writer); 
        }

        public static WConfiguration DeserializeWConfiguration(BinaryReader reader)
        {
            return WConfiguration.Deserialize(reader); 
        }

        public static int CalculateSize(WConfiguration value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WContext
    {
        /// 
        public String[] things;
        /// 
        public Dictionary<String, String> headers;

        /// <summary>Empty constructor</summary>
        public WContext() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WContext(String[] things, Dictionary<String, String> headers)
        {
            this.things = things;
            this.headers = headers;
        }

        public override string ToString()
        {
            return "WContext { things = " + things + ", headers = " + headers + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WContext object
        /// </summary>
        public static WContext Deserialize(BinaryReader reader)
        {
            return new WContext {
                things = WireInterop.DeserializeVec<String>(reader, WireInterop.DeserializeString), /* vec */
                
                
                headers = WireInterop.DeserializeMap<String, String>(reader, WireInterop.DeserializeString, WireInterop.DeserializeString), /* map */
            };

        }

        /// <summary>
        /// Serialize a WContext object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.things, WireInterop.SerializeString); /* vec */


            WireInterop.SerializeMap(writer, this.headers, WireInterop.SerializeString, WireInterop.SerializeString); /* map */

        }

        /// <summary>
        /// Calculate the size needed to serialize a WContext object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 

            WireInterop.CalculateVariableVecSize(this.things, SerdeStringExtensions.CalculateSize) /* vec */


                + 

            WireInterop.CalculateVariableMapSize(this.headers, SerdeStringExtensions.CalculateSize, SerdeStringExtensions.CalculateSize) /* map */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WContext to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWContextExtensions
    {
        public static void SerializeWContext(BinaryWriter writer, WContext item)
        {
            item.Serialize(writer); 
        }

        public static WContext DeserializeWContext(BinaryReader reader)
        {
            return WContext.Deserialize(reader); 
        }

        public static int CalculateSize(WContext value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WData
    {
        /// 
        public WItems items;
        /// 
        public WError? errors;

        /// <summary>Empty constructor</summary>
        public WData() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WData(WItems items, WError? errors)
        {
            this.items = items;
            this.errors = errors;
        }

        public override string ToString()
        {
            return "WData { items = " + items + ", errors = " + errors + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WData object
        /// </summary>
        public static WData Deserialize(BinaryReader reader)
        {
            return new WData {
                items = SerdeWItemsExtensions.DeserializeWItems(reader), /* composite */
                errors = WireInterop.DeserializeOptional(reader, SerdeWErrorExtensions.DeserializeWError), /* optional */
            };

        }

        /// <summary>
        /// Serialize a WData object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.items.Serialize(writer); /* composite */
            WireInterop.SerializeOptional<WError>(writer, this.errors, SerdeWErrorExtensions.SerializeWError);  /* optional */

        }

        /// <summary>
        /// Calculate the size needed to serialize a WData object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            this.items.CalculateSize() /* composite */

                + 
            1 + (this.errors != null ? Marshal.SizeOf<WError>() : 0) /* optional */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WData to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWDataExtensions
    {
        public static void SerializeWData(BinaryWriter writer, WData item)
        {
            item.Serialize(writer); 
        }

        public static WData DeserializeWData(BinaryReader reader)
        {
            return WData.Deserialize(reader); 
        }

        public static int CalculateSize(WData value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WError
    {
        /// 
        public String[] error_messages;

        /// <summary>Empty constructor</summary>
        public WError() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WError(String[] error_messages)
        {
            this.error_messages = error_messages;
        }

        public override string ToString()
        {
            return "WError { error_messages = " + error_messages + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WError object
        /// </summary>
        public static WError Deserialize(BinaryReader reader)
        {
            return new WError {
                error_messages = WireInterop.DeserializeVec<String>(reader, WireInterop.DeserializeString), /* vec */
                
            };

        }

        /// <summary>
        /// Serialize a WError object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.error_messages, WireInterop.SerializeString); /* vec */


        }

        /// <summary>
        /// Calculate the size needed to serialize a WError object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 

            WireInterop.CalculateVariableVecSize(this.error_messages, SerdeStringExtensions.CalculateSize) /* vec */


            ;

        }
    }

    /// <summary>
    /// Extension methods for WError to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWErrorExtensions
    {
        public static void SerializeWError(BinaryWriter writer, WError item)
        {
            item.Serialize(writer); 
        }

        public static WError DeserializeWError(BinaryReader reader)
        {
            return WError.Deserialize(reader); 
        }

        public static int CalculateSize(WError value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WInput
    {
        /// 
        public WContext context;
        /// 
        public WTable value;
        /// 
        public WConfiguration configuration;

        /// <summary>Empty constructor</summary>
        public WInput() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WInput(WContext context, WTable value, WConfiguration configuration)
        {
            this.context = context;
            this.value = value;
            this.configuration = configuration;
        }

        public override string ToString()
        {
            return "WInput { context = " + context + ", value = " + value + ", configuration = " + configuration + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WInput object
        /// </summary>
        public static WInput Deserialize(BinaryReader reader)
        {
            return new WInput {
                context = SerdeWContextExtensions.DeserializeWContext(reader), /* composite */
                value = SerdeWTableExtensions.DeserializeWTable(reader), /* composite */
                configuration = SerdeWConfigurationExtensions.DeserializeWConfiguration(reader), /* composite */
            };

        }

        /// <summary>
        /// Serialize a WInput object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.context.Serialize(writer); /* composite */
            this.value.Serialize(writer); /* composite */
            this.configuration.Serialize(writer); /* composite */

        }

        /// <summary>
        /// Calculate the size needed to serialize a WInput object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            this.context.CalculateSize() /* composite */

                + 
            this.value.CalculateSize() /* composite */

                + 
            this.configuration.CalculateSize() /* composite */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WInput to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWInputExtensions
    {
        public static void SerializeWInput(BinaryWriter writer, WInput item)
        {
            item.Serialize(writer); 
        }

        public static WInput DeserializeWInput(BinaryReader reader)
        {
            return WInput.Deserialize(reader); 
        }

        public static int CalculateSize(WInput value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// FFI-safe wire representation for WInput.
    /// Mirrors the Rust Wire&lt;WInput&gt; structure layout.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct WireOfWInput
    {
        /// <summary>Pointer to buffer data</summary>
        public byte* Data;

        /// <summary>Length of valid data in buffer</summary>
        public int Length;

        /// <summary>
        /// Encoded capacity: 0=borrowed, >0=Rust-allocated, <0=C#-allocated (abs value = actual capacity)
        /// </summary>
        public int Capacity;

        /// <summary>
        /// Create a Wire from a managed WInput object with owned buffer
        /// </summary>
        public static WireOfWInput From(WInput value)
        {
            var size = value.CalculateSize();
            var buffer = Marshal.AllocHGlobal(size);
            var wire = new WireOfWInput
            {
                Data = (byte*)buffer,
                Length = (int)size,
                Capacity = -(int)size
            };

            try
            {
                value.Serialize(wire.Writer());
                return wire;
            }
            catch
            {
                Marshal.FreeHGlobal(buffer);
                throw;
            }
        }

        /// <summary>
        /// Create a Wire from a managed WInput object using provided buffer
        /// </summary>
        public static WireOfWInput From(WInput value, byte* buffer, int bufferSize)
        {
            var size = value.CalculateSize();
            if (size > bufferSize)
                throw new ArgumentException($"Buffer size {bufferSize} is too small for data size {size} when serializing WInput");

            var wire = new WireOfWInput
            {
                Data = buffer,
                Length = (int)size,
                Capacity = 0 // Indicates borrowed buffer
            };

            value.Serialize(wire.Writer());
            return wire;
        }

        public BinaryReader Reader()
        {
            // UIntPtr Ptr = (UIntPtr)Data;
            // throw new ArgumentException($"Creating a reader for wire with {Length} bytes in it, {Ptr} ptr and {Capacity} capacity");
            var reader = new BinaryReader(new UnmanagedMemoryStream(Data, Length));
            return reader;
        }

        public BinaryWriter Writer()
        {
            var writer = new BinaryWriter(new UnmanagedMemoryStream(Data, Length, Length, FileAccess.Write));
            return writer;
        }

        /// <summary>
        /// Free the buffer if this wire owns it
        /// </summary>
        public void Dispose()
        {
            if (Data != null)
            {
                if (IsOwned) {
                    if (Capacity > 0) {
                        WireInterop.deallocate_wire_buffer_storage((IntPtr)Data, Length, Capacity);
                    } else {
                        Marshal.FreeHGlobal((IntPtr)Data);
                    }
                }
                Data = null;
                Length = 0;
                Capacity = 0;
            }
        }

        /// <summary>
        /// Check if this wire owns its buffer
        /// </summary>
        public bool IsOwned => Capacity != 0;

        /// <summary>
        /// Check if the wire buffer is empty
        /// </summary>
        public bool IsEmpty => Length == 0;
    }

    /// <summary>
    /// Extension methods for WInput to create Wire instances
    /// </summary>
    public static class WireOfWInputExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this WInput instance
        /// </summary>
        public static WireOfWInput Wire(this WInput value)
        {
            return WireOfWInput.From(value);
        }

        /// <summary>
        /// Create a Wire with borrowed buffer from this WInput instance
        /// </summary>
        public static unsafe WireOfWInput WireWithBuffer(this WInput value, byte* buffer, int bufferSize)
        {
            return WireOfWInput.From(value, buffer, bufferSize);
        }

        /// <summary>
        /// Calculate the wire size needed for this WInput instance
        /// </summary>
        public static int WireSize(this WInput value)
        {
            return value.CalculateSize();
        }

        /// <summary>
        /// Unwire a WireOfWInput back to a managed WInput object
        /// </summary>
        public static WInput Unwire(this WireOfWInput wire)
        {
            return WInput.Deserialize(wire.Reader());
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WItem
    {
        /// 
        public WItemKey key;
        /// 
        public ulong value;

        /// <summary>Empty constructor</summary>
        public WItem() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WItem(WItemKey key, ulong value)
        {
            this.key = key;
            this.value = value;
        }

        public override string ToString()
        {
            return "WItem { key = " + key + ", value = " + value + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WItem object
        /// </summary>
        public static WItem Deserialize(BinaryReader reader)
        {
            return new WItem {
                key = WireInterop.DeserializeEnum<WItemKey>(reader), /* enum */
                
            value = reader.ReadUInt64(),


            };

        }

        /// <summary>
        /// Serialize a WItem object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.key.Serialize(writer); /* enum */

            writer.Write(this.value);



        }

        /// <summary>
        /// Calculate the size needed to serialize a WItem object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            Marshal.SizeOf<ulong>() /* enum */

                + 
            8 /* primitive */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WItem to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWItemExtensions
    {
        public static void SerializeWItem(BinaryWriter writer, WItem item)
        {
            item.Serialize(writer); 
        }

        public static WItem DeserializeWItem(BinaryReader reader)
        {
            return WItem.Deserialize(reader); 
        }

        public static int CalculateSize(WItem value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WItems
    {
        /// 
        public WItem[] items;

        /// <summary>Empty constructor</summary>
        public WItems() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WItems(WItem[] items)
        {
            this.items = items;
        }

        public override string ToString()
        {
            return "WItems { items = " + items + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WItems object
        /// </summary>
        public static WItems Deserialize(BinaryReader reader)
        {
            return new WItems {
                items = WireInterop.DeserializeVec<WItem>(reader, SerdeWItemExtensions.DeserializeWItem), /* vec */
                
            };

        }

        /// <summary>
        /// Serialize a WItems object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.items, SerdeWItemExtensions.SerializeWItem); /* vec */


        }

        /// <summary>
        /// Calculate the size needed to serialize a WItems object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 

            WireInterop.CalculateVariableVecSize(this.items, SerdeWItemExtensions.CalculateSize) /* vec */


            ;

        }
    }

    /// <summary>
    /// Extension methods for WItems to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWItemsExtensions
    {
        public static void SerializeWItems(BinaryWriter writer, WItems item)
        {
            item.Serialize(writer); 
        }

        public static WItems DeserializeWItems(BinaryReader reader)
        {
            return WItems.Deserialize(reader); 
        }

        public static int CalculateSize(WItems value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WOutputs
    {
        /// 
        public WResponse response;
        /// 
        public WData data;

        /// <summary>Empty constructor</summary>
        public WOutputs() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WOutputs(WResponse response, WData data)
        {
            this.response = response;
            this.data = data;
        }

        public override string ToString()
        {
            return "WOutputs { response = " + response + ", data = " + data + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WOutputs object
        /// </summary>
        public static WOutputs Deserialize(BinaryReader reader)
        {
            return new WOutputs {
                response = SerdeWResponseExtensions.DeserializeWResponse(reader), /* composite */
                data = SerdeWDataExtensions.DeserializeWData(reader), /* composite */
            };

        }

        /// <summary>
        /// Serialize a WOutputs object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.response.Serialize(writer); /* composite */
            this.data.Serialize(writer); /* composite */

        }

        /// <summary>
        /// Calculate the size needed to serialize a WOutputs object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            this.response.CalculateSize() /* composite */

                + 
            this.data.CalculateSize() /* composite */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WOutputs to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWOutputsExtensions
    {
        public static void SerializeWOutputs(BinaryWriter writer, WOutputs item)
        {
            item.Serialize(writer); 
        }

        public static WOutputs DeserializeWOutputs(BinaryReader reader)
        {
            return WOutputs.Deserialize(reader); 
        }

        public static int CalculateSize(WOutputs value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// FFI-safe wire representation for WOutputs.
    /// Mirrors the Rust Wire&lt;WOutputs&gt; structure layout.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct WireOfWOutputs
    {
        /// <summary>Pointer to buffer data</summary>
        public byte* Data;

        /// <summary>Length of valid data in buffer</summary>
        public int Length;

        /// <summary>
        /// Encoded capacity: 0=borrowed, >0=Rust-allocated, <0=C#-allocated (abs value = actual capacity)
        /// </summary>
        public int Capacity;

        /// <summary>
        /// Create a Wire from a managed WOutputs object with owned buffer
        /// </summary>
        public static WireOfWOutputs From(WOutputs value)
        {
            var size = value.CalculateSize();
            var buffer = Marshal.AllocHGlobal(size);
            var wire = new WireOfWOutputs
            {
                Data = (byte*)buffer,
                Length = (int)size,
                Capacity = -(int)size
            };

            try
            {
                value.Serialize(wire.Writer());
                return wire;
            }
            catch
            {
                Marshal.FreeHGlobal(buffer);
                throw;
            }
        }

        /// <summary>
        /// Create a Wire from a managed WOutputs object using provided buffer
        /// </summary>
        public static WireOfWOutputs From(WOutputs value, byte* buffer, int bufferSize)
        {
            var size = value.CalculateSize();
            if (size > bufferSize)
                throw new ArgumentException($"Buffer size {bufferSize} is too small for data size {size} when serializing WOutputs");

            var wire = new WireOfWOutputs
            {
                Data = buffer,
                Length = (int)size,
                Capacity = 0 // Indicates borrowed buffer
            };

            value.Serialize(wire.Writer());
            return wire;
        }

        public BinaryReader Reader()
        {
            // UIntPtr Ptr = (UIntPtr)Data;
            // throw new ArgumentException($"Creating a reader for wire with {Length} bytes in it, {Ptr} ptr and {Capacity} capacity");
            var reader = new BinaryReader(new UnmanagedMemoryStream(Data, Length));
            return reader;
        }

        public BinaryWriter Writer()
        {
            var writer = new BinaryWriter(new UnmanagedMemoryStream(Data, Length, Length, FileAccess.Write));
            return writer;
        }

        /// <summary>
        /// Free the buffer if this wire owns it
        /// </summary>
        public void Dispose()
        {
            if (Data != null)
            {
                if (IsOwned) {
                    if (Capacity > 0) {
                        WireInterop.deallocate_wire_buffer_storage((IntPtr)Data, Length, Capacity);
                    } else {
                        Marshal.FreeHGlobal((IntPtr)Data);
                    }
                }
                Data = null;
                Length = 0;
                Capacity = 0;
            }
        }

        /// <summary>
        /// Check if this wire owns its buffer
        /// </summary>
        public bool IsOwned => Capacity != 0;

        /// <summary>
        /// Check if the wire buffer is empty
        /// </summary>
        public bool IsEmpty => Length == 0;
    }

    /// <summary>
    /// Extension methods for WOutputs to create Wire instances
    /// </summary>
    public static class WireOfWOutputsExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this WOutputs instance
        /// </summary>
        public static WireOfWOutputs Wire(this WOutputs value)
        {
            return WireOfWOutputs.From(value);
        }

        /// <summary>
        /// Create a Wire with borrowed buffer from this WOutputs instance
        /// </summary>
        public static unsafe WireOfWOutputs WireWithBuffer(this WOutputs value, byte* buffer, int bufferSize)
        {
            return WireOfWOutputs.From(value, buffer, bufferSize);
        }

        /// <summary>
        /// Calculate the wire size needed for this WOutputs instance
        /// </summary>
        public static int WireSize(this WOutputs value)
        {
            return value.CalculateSize();
        }

        /// <summary>
        /// Unwire a WireOfWOutputs back to a managed WOutputs object
        /// </summary>
        public static WOutputs Unwire(this WireOfWOutputs wire)
        {
            return WOutputs.Deserialize(wire.Reader());
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WResponse
    {
        /// 
        public WResult[] results;

        /// <summary>Empty constructor</summary>
        public WResponse() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WResponse(WResult[] results)
        {
            this.results = results;
        }

        public override string ToString()
        {
            return "WResponse { results = " + results + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WResponse object
        /// </summary>
        public static WResponse Deserialize(BinaryReader reader)
        {
            return new WResponse {
                results = WireInterop.DeserializeVec<WResult>(reader, SerdeWResultExtensions.DeserializeWResult), /* vec */
                
            };

        }

        /// <summary>
        /// Serialize a WResponse object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.results, SerdeWResultExtensions.SerializeWResult); /* vec */


        }

        /// <summary>
        /// Calculate the size needed to serialize a WResponse object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 

            WireInterop.CalculateVariableVecSize(this.results, SerdeWResultExtensions.CalculateSize) /* vec */


            ;

        }
    }

    /// <summary>
    /// Extension methods for WResponse to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWResponseExtensions
    {
        public static void SerializeWResponse(BinaryWriter writer, WResponse item)
        {
            item.Serialize(writer); 
        }

        public static WResponse DeserializeWResponse(BinaryReader reader)
        {
            return WResponse.Deserialize(reader); 
        }

        public static int CalculateSize(WResponse value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WResult
    {
        /// 
        public String item_id;
        /// 
        public int item_value;

        /// <summary>Empty constructor</summary>
        public WResult() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WResult(String item_id, int item_value)
        {
            this.item_id = item_id;
            this.item_value = item_value;
        }

        public override string ToString()
        {
            return "WResult { item_id = " + item_id + ", item_value = " + item_value + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WResult object
        /// </summary>
        public static WResult Deserialize(BinaryReader reader)
        {
            return new WResult {
                item_id = WireInterop.DeserializeString(reader), /* string */
                
            item_value = reader.ReadInt32(),


            };

        }

        /// <summary>
        /// Serialize a WResult object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.item_id.Serialize(writer); /* string */

            writer.Write(this.item_value);



        }

        /// <summary>
        /// Calculate the size needed to serialize a WResult object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(this.item_id ?? "") /* string */

                + 
            4 /* primitive */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WResult to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWResultExtensions
    {
        public static void SerializeWResult(BinaryWriter writer, WResult item)
        {
            item.Serialize(writer); 
        }

        public static WResult DeserializeWResult(BinaryReader reader)
        {
            return WResult.Deserialize(reader); 
        }

        public static int CalculateSize(WResult value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WTable
    {
        /// 
        public WTableMetadata metadata;
        /// 
        public byte[] byte_array;

        /// <summary>Empty constructor</summary>
        public WTable() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WTable(WTableMetadata metadata, byte[] byte_array)
        {
            this.metadata = metadata;
            this.byte_array = byte_array;
        }

        public override string ToString()
        {
            return "WTable { metadata = " + metadata + ", byte_array = " + byte_array + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WTable object
        /// </summary>
        public static WTable Deserialize(BinaryReader reader)
        {
            return new WTable {
                metadata = SerdeWTableMetadataExtensions.DeserializeWTableMetadata(reader), /* composite */
                byte_array = WireInterop.DeserializeVecOfByte(reader), /* vec */
            };

        }

        /// <summary>
        /// Serialize a WTable object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.metadata.Serialize(writer); /* composite */
            WireInterop.SerializeVecOfByte(writer, this.byte_array); /* vec */

        }

        /// <summary>
        /// Calculate the size needed to serialize a WTable object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            this.metadata.CalculateSize() /* composite */

                + 

            Marshal.SizeOf<ulong>() + this.byte_array.Length * Marshal.SizeOf<byte>()


            ;

        }
    }

    /// <summary>
    /// Extension methods for WTable to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWTableExtensions
    {
        public static void SerializeWTable(BinaryWriter writer, WTable item)
        {
            item.Serialize(writer); 
        }

        public static WTable DeserializeWTable(BinaryReader reader)
        {
            return WTable.Deserialize(reader); 
        }

        public static int CalculateSize(WTable value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class WTableMetadata
    {
        /// 
        public int row_count;
        /// 
        public int column_count;
        /// 
        public String guid;
        /// 
        public String prefix;

        /// <summary>Empty constructor</summary>
        public WTableMetadata() { }

        /// <summary>Member-wise initializing constructor</summary>
        public WTableMetadata(int row_count, int column_count, String guid, String prefix)
        {
            this.row_count = row_count;
            this.column_count = column_count;
            this.guid = guid;
            this.prefix = prefix;
        }

        public override string ToString()
        {
            return "WTableMetadata { row_count = " + row_count + ", column_count = " + column_count + ", guid = " + guid + ", prefix = " + prefix + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed WTableMetadata object
        /// </summary>
        public static WTableMetadata Deserialize(BinaryReader reader)
        {
            return new WTableMetadata {
                
            row_count = reader.ReadInt32(),


                
            column_count = reader.ReadInt32(),


                guid = WireInterop.DeserializeString(reader), /* string */
                prefix = WireInterop.DeserializeString(reader), /* string */
            };

        }

        /// <summary>
        /// Serialize a WTableMetadata object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {


            writer.Write(this.row_count);



            writer.Write(this.column_count);


            this.guid.Serialize(writer); /* string */
            this.prefix.Serialize(writer); /* string */

        }

        /// <summary>
        /// Calculate the size needed to serialize a WTableMetadata object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            4 /* primitive */

                + 
            4 /* primitive */

                + 
            Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(this.guid ?? "") /* string */

                + 
            Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(this.prefix ?? "") /* string */

            ;

        }
    }

    /// <summary>
    /// Extension methods for WTableMetadata to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeWTableMetadataExtensions
    {
        public static void SerializeWTableMetadata(BinaryWriter writer, WTableMetadata item)
        {
            item.Serialize(writer); 
        }

        public static WTableMetadata DeserializeWTableMetadata(BinaryReader reader)
        {
            return WTableMetadata.Deserialize(reader); 
        }

        public static int CalculateSize(WTableMetadata value)
        {
            return value.CalculateSize(); 
        }
    }

    public enum WItemKey
    {

        TOTAL = 0,

        FIRST = 1,

        SECOND = 2,

        THIRD = 3,

    }

    public static class WireWItemKeyExtensions
    {
        public static void Serialize(this WItemKey value, BinaryWriter writer) {
            writer.Write((int)value); /* only works for unit enum variants */
        }
    }




    public partial class WireInterop {
        [LibraryImport(Interop.NativeLib, EntryPoint = "deallocate_wire_buffer_storage")]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void deallocate_wire_buffer_storage(IntPtr data, int len, int capacity);

        #region Serialization Helpers
        #nullable enable

        public static void SerializeString(BinaryWriter writer, string value)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            var bytes = Encoding.UTF8.GetBytes(value);
            writer.Write((ulong)bytes.Length);
            writer.Write(bytes);
        }

        public static string DeserializeString(BinaryReader reader)
        {
            var length = reader.ReadUInt64();
            if (length == 0)
                return string.Empty;

            var bytes = reader.ReadBytes((int)length);
            return Encoding.UTF8.GetString(bytes);
        }

        public static void SerializeVecOfByte(BinaryWriter writer, byte[] vec)
        {
            writer.Write((ulong)vec.Length);
            writer.Write(vec);
        }

        public static void SerializeVec<T>(BinaryWriter writer, IList<T> value, Action<BinaryWriter, T> serializeItem)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            writer.Write((ulong)value.Count);
            foreach (var item in value)
            {
                serializeItem(writer, item);
            }
        }

        public static byte[] DeserializeVecOfByte(BinaryReader reader)
        {
            var length = reader.ReadUInt64();
            return reader.ReadBytes((int)length);
        }

        public static T[] DeserializeVec<T>(BinaryReader reader, Func<BinaryReader, T> deserializeItem)
        {
            var length = reader.ReadUInt64();
            var result = new T[(int)length];

            for (ulong i = 0; i < length; i++)
            {
                result[i] = deserializeItem(reader);
            }

            return result;
        }

        public static void SerializeMap<K,V>(BinaryWriter writer, IDictionary<K,V> value, Action<BinaryWriter, K> serializeKey, Action<BinaryWriter, V> serializeValue)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            writer.Write((ulong)value.Count);
            foreach (var item in value)
            {
                serializeKey(writer, item.Key);
                serializeValue(writer, item.Value);
            }
        }

        public static Dictionary<K,V> DeserializeMap<K,V>(BinaryReader reader, Func<BinaryReader, K> deserializeKey, Func<BinaryReader, V> deserializeValue)
        {
            var length = reader.ReadUInt64();
            var result = new Dictionary<K,V>((int)length);

            for (ulong i = 0; i < length; i++)
            {
                var k = deserializeKey(reader);
                var v = deserializeValue(reader);
                result.Add(k, v);
            }

            return result;
        }

        public static void SerializeOptional<T>(BinaryWriter writer, T? value, Action<BinaryWriter, T> serializeItem)
        {
            if (value != null)
            {
                writer.Write((byte)1);
                serializeItem(writer, value);
            }
            else
            {
                writer.Write((byte)0);
            }
        }

        #nullable enable
        public static T? DeserializeOptional<T>(BinaryReader reader, Func<BinaryReader, T> deserializeValue)
        {
            var hasValue = reader.ReadByte() != 0;
            if (hasValue)
            {
                return deserializeValue(reader);
            }
            return default;
        }
        #nullable restore

        public static T? DeserializeEnum<T>(BinaryReader reader) where T: System.Enum
        {
            var discriminant = reader.ReadInt32();
            if (Enum.IsDefined(typeof(T), discriminant))
            {
                return (T)Enum.ToObject(typeof(T), discriminant);
            }
            return default(T);
        }

        public static int CalculateVariableMapSize<K,V>(IDictionary<K,V> value, Func<K, int> calculateKeySize, Func<V, int> calculateValueSize)
        {
            int size = Marshal.SizeOf<ulong>(); // length field
            if (value == null) return size;

            foreach (var item in value)
            {
                size +=
                    calculateKeySize(item.Key)
                    + calculateValueSize(item.Value);}
            return size;
        }

        /// This method is called only for non-primitive inner types which require size calculations.
        public static int CalculateVariableVecSize<T>(IList<T> value, Func<T, int> calculateItemSize)
        {
            int size = Marshal.SizeOf<ulong>(); // length field
            if (value == null) return size;foreach (var item in value)
            {
                size += calculateItemSize(item);
            }
            return size;
        }

        #nullable restore
        #endregion
    }

    public static class SerdeStringExtensions
    {
        public static void Serialize(this String value, BinaryWriter writer) {
            WireInterop.SerializeString(writer, value);
        }

        public static String DeserializeString(BinaryReader reader) {
            return WireInterop.DeserializeString(reader);
        }

        public static int CalculateSize(String value) {
            return Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(value ?? "");
        }
    }
}
