// <auto-generated>
//
// This file was automatically generated by Interoptopus.
//
// Library:      proto_benchy
// Hash:         0x4c14922766f96bfc
// Namespace:    wire
// Builder:      interoptopus_backend_csharp
//
// Do not edit this file manually.
//
// </auto-generated>

#pragma warning disable 0105
using System;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Runtime.CompilerServices;
using Gen.Ffi;
using Gen.ForCSharp;
using Gen.Wire;
#pragma warning restore 0105

namespace Gen.Wire
{
    public static partial class Interop
    {
        public const string NativeLib = "proto_benchy";

        static Interop()
        {
        }



        /// Main benchmark entry point for wire based interop.
        [LibraryImport(NativeLib, EntryPoint = "WireRustClient")]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial WireOfOutputs WireRustClient(WireOfInput wire_input);


    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Configuration
    {
        /// 
        public bool is_ok_response;
        /// 
        public String host;
        /// 
        public ulong response_size;

        /// <summary>Empty constructor</summary>
        public Configuration() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Configuration(bool is_ok_response, String host, ulong response_size)
        {
            this.is_ok_response = is_ok_response;
            this.host = host;
            this.response_size = response_size;
        }

        public override string ToString()
        {
            return "Configuration { is_ok_response = " + is_ok_response + ", host = " + host + ", response_size = " + response_size + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Configuration object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Configuration Deserialize(BinaryReader reader)
        {
            return new Configuration {
                
            is_ok_response = reader.ReadByte() != 0,


                host = WireInterop.DeserializeString(reader), /* string */
                
            response_size = reader.ReadUInt64(),


            };

        }

        /// <summary>
        /// Serialize a Configuration object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {


            writer.Write((byte)(this.is_ok_response ? 1 : 0));


            this.host.Serialize(writer); /* string */

            writer.Write((ulong)this.response_size);



        }

        /// <summary>
        /// Calculate the size needed to serialize a Configuration object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += 1; /* primitive */
            size += 8 + System.Text.Encoding.UTF8.GetByteCount(this.host ?? ""); /* string */
            size += 8; /* primitive */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Configuration to Deserialize instances
    /// </summary>
    public static class DeserConfigurationExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Configuration instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Configuration DeserializeConfiguration(BinaryReader reader)
        {
            return Configuration.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Context
    {
        /// 
        public String[] things;
        /// 
        public Dictionary<String, String> headers;

        /// <summary>Empty constructor</summary>
        public Context() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Context(String[] things, Dictionary<String, String> headers)
        {
            this.things = things;
            this.headers = headers;
        }

        public override string ToString()
        {
            return "Context { things = " + things + ", headers = " + headers + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Context object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Context Deserialize(BinaryReader reader)
        {
            return new Context {
                things = WireInterop.DeserializeVec<String>(reader, DeserStringExtensions.DeserializeString), /* vec */
                
                
                headers = WireInterop.DeserializeMap<String, String>(reader, DeserStringExtensions.DeserializeString, DeserStringExtensions.DeserializeString), /* map */
            };

        }

        /// <summary>
        /// Serialize a Context object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.things); /* vec */
            WireInterop.SerializeMap(writer, this.headers); /* map */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Context object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += WireInterop.CalculateVecSize(this.things); /* vec */
            size += this.headers.CalculateSize(); /* map */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Context to Deserialize instances
    /// </summary>
    public static class DeserContextExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Context instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Context DeserializeContext(BinaryReader reader)
        {
            return Context.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Data
    {
        /// 
        public Items items;
        /// 
        public Error errors;

        /// <summary>Empty constructor</summary>
        public Data() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Data(Items items, Error errors)
        {
            this.items = items;
            this.errors = errors;
        }

        public override string ToString()
        {
            return "Data { items = " + items + ", errors = " + errors + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Data object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Data Deserialize(BinaryReader reader)
        {
            return new Data {
                items = DeserItemsExtensions.DeserializeItems(reader), /* composite */
                errors = DeserErrorExtensions.DeserializeError(reader), /* composite */
            };

        }

        /// <summary>
        /// Serialize a Data object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            this.items.Serialize(writer); /* composite */
            this.errors.Serialize(writer); /* composite */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Data object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += this.items.CalculateSize(); /* composite */
            size += this.errors.CalculateSize(); /* composite */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Data to Deserialize instances
    /// </summary>
    public static class DeserDataExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Data instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Data DeserializeData(BinaryReader reader)
        {
            return Data.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Error
    {
        /// 
        public String[] error_messages;

        /// <summary>Empty constructor</summary>
        public Error() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Error(String[] error_messages)
        {
            this.error_messages = error_messages;
        }

        public override string ToString()
        {
            return "Error { error_messages = " + error_messages + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Error object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Error Deserialize(BinaryReader reader)
        {
            return new Error {
                error_messages = WireInterop.DeserializeVec<String>(reader, DeserStringExtensions.DeserializeString), /* vec */
                
            };

        }

        /// <summary>
        /// Serialize a Error object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.error_messages); /* vec */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Error object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += WireInterop.CalculateVecSize(this.error_messages); /* vec */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Error to Deserialize instances
    /// </summary>
    public static class DeserErrorExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Error instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Error DeserializeError(BinaryReader reader)
        {
            return Error.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Input
    {
        /// 
        public Context context;
        /// 
        public Table value;
        /// 
        public Configuration configuration;

        /// <summary>Empty constructor</summary>
        public Input() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Input(Context context, Table value, Configuration configuration)
        {
            this.context = context;
            this.value = value;
            this.configuration = configuration;
        }

        public override string ToString()
        {
            return "Input { context = " + context + ", value = " + value + ", configuration = " + configuration + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Input object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Input Deserialize(BinaryReader reader)
        {
            return new Input {
                context = DeserContextExtensions.DeserializeContext(reader), /* composite */
                value = DeserTableExtensions.DeserializeTable(reader), /* composite */
                configuration = DeserConfigurationExtensions.DeserializeConfiguration(reader), /* composite */
            };

        }

        /// <summary>
        /// Serialize a Input object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            this.context.Serialize(writer); /* composite */
            this.value.Serialize(writer); /* composite */
            this.configuration.Serialize(writer); /* composite */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Input object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += this.context.CalculateSize(); /* composite */
            size += this.value.CalculateSize(); /* composite */
            size += this.configuration.CalculateSize(); /* composite */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Input to Deserialize instances
    /// </summary>
    public static class DeserInputExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Input instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Input DeserializeInput(BinaryReader reader)
        {
            return Input.Deserialize(reader); 
        }
    }

    /// <summary>
    /// FFI-safe wire representation for Input.
    /// Mirrors the Rust Wire&lt;Input&gt; structure layout.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct WireOfInput
    {
        /// <summary>Pointer to buffer data</summary>
        public byte* Data;

        /// <summary>Length of valid data in buffer</summary>
        public long Length;

        /// <summary>Capacity of buffer (0 for borrowed buffers)</summary>
        public long Capacity;

        /// <summary>
        /// Create a Wire from a managed Input object with owned buffer
        /// </summary>
        public static WireOfInput From(Input value)
        {
            var size = value.CalculateSize();
            var buffer = Marshal.AllocHGlobal(size);
            var wire = new WireOfInput
            {
                Data = (byte*)buffer,
                Length = (long)size,
                Capacity = (long)size
            };

            try
            {
                value.Serialize(wire.Writer());
                return wire;
            }
            catch
            {
                Marshal.FreeHGlobal(buffer);
                throw;
            }
        }

        /// <summary>
        /// Create a Wire from a managed Input object using provided buffer
        /// </summary>
        public static WireOfInput From(Input value, byte* buffer, int bufferSize)
        {
            var wire = new WireOfInput
            {
                Data = buffer,
                Length = 0,
                Capacity = 0 // Indicates borrowed buffer
            };

            var size = value.CalculateSize();
            if (size > bufferSize)
                throw new ArgumentException($"Buffer size {bufferSize} is too small for data size {size} when serializing Input");

            wire.Length = (long)size;
            value.Serialize(wire.Writer());
            return wire;
        }

        public BinaryReader Reader()
        {
            // UIntPtr Ptr = (UIntPtr)Data;
            // throw new ArgumentException($"Creating a reader for wire with {Length} bytes in it, {Ptr} ptr and {Capacity} capacity");
            var reader = new BinaryReader(new UnmanagedMemoryStream(Data, Length));
            return reader;
        }

        public BinaryWriter Writer()
        {
            var writer = new BinaryWriter(new UnmanagedMemoryStream(Data, Length, Length, FileAccess.Write));
            return writer;
        }

        /// <summary>
        /// Free the buffer if this wire owns it
        /// </summary>
        public void Dispose()
        {
            if (Data != null && IsOwned)
            {
                Marshal.FreeHGlobal((IntPtr)Data);
                Data = null;
                Length = 0;
                Capacity = 0;
            }
        }

        /// <summary>
        /// Check if this wire owns its buffer
        /// </summary>
        public bool IsOwned => Capacity > 0;

        /// <summary>
        /// Check if the wire buffer is empty
        /// </summary>
        public bool IsEmpty => Length == 0;

    }

    /// <summary>
    /// Extension methods for Input to create Wire instances
    /// </summary>
    public static class WireOfInputExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Input instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static WireOfInput Wire(this Input value)
        {
            return WireOfInput.From(value);
        }

        /// <summary>
        /// Create a Wire with borrowed buffer from this Input instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe WireOfInput WireWithBuffer(this Input value, byte* buffer, int bufferSize)
        {
            return WireOfInput.From(value, buffer, bufferSize);
        }

        /// <summary>
        /// Calculate the wire size needed for this Input instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static int WireSize(this Input value)
        {
            return value.CalculateSize();
        }

        /// <summary>
        /// Unwire a WireOfInput back to a managed Input object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Input Unwire(this WireOfInput wire)
        {
            return Input.Deserialize(wire.Reader());
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Item
    {
        /// 
        public ItemKey key;
        /// 
        public ulong value;

        /// <summary>Empty constructor</summary>
        public Item() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Item(ItemKey key, ulong value)
        {
            this.key = key;
            this.value = value;
        }

        public override string ToString()
        {
            return "Item { key = " + key + ", value = " + value + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Item object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Item Deserialize(BinaryReader reader)
        {
            return new Item {
                key = WireInterop.DeserializeEnum<ItemKey>(reader), /* enum */
                
            value = reader.ReadUInt64(),


            };

        }

        /// <summary>
        /// Serialize a Item object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            this.key.Serialize(writer); /* enum */

            writer.Write((ulong)this.value);



        }

        /// <summary>
        /// Calculate the size needed to serialize a Item object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += 8; /* enum */
            size += 8; /* primitive */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Item to Deserialize instances
    /// </summary>
    public static class DeserItemExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Item instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Item DeserializeItem(BinaryReader reader)
        {
            return Item.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Items
    {
        /// 
        public Item[] items;

        /// <summary>Empty constructor</summary>
        public Items() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Items(Item[] items)
        {
            this.items = items;
        }

        public override string ToString()
        {
            return "Items { items = " + items + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Items object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Items Deserialize(BinaryReader reader)
        {
            return new Items {
                items = WireInterop.DeserializeVec<Item>(reader, DeserItemExtensions.DeserializeItem), /* vec */
                
            };

        }

        /// <summary>
        /// Serialize a Items object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.items); /* vec */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Items object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += WireInterop.CalculateVecSize(this.items); /* vec */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Items to Deserialize instances
    /// </summary>
    public static class DeserItemsExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Items instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Items DeserializeItems(BinaryReader reader)
        {
            return Items.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Outputs
    {
        /// 
        public Response response;
        /// 
        public Data data;

        /// <summary>Empty constructor</summary>
        public Outputs() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Outputs(Response response, Data data)
        {
            this.response = response;
            this.data = data;
        }

        public override string ToString()
        {
            return "Outputs { response = " + response + ", data = " + data + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Outputs object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Outputs Deserialize(BinaryReader reader)
        {
            return new Outputs {
                response = DeserResponseExtensions.DeserializeResponse(reader), /* composite */
                data = DeserDataExtensions.DeserializeData(reader), /* composite */
            };

        }

        /// <summary>
        /// Serialize a Outputs object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            this.response.Serialize(writer); /* composite */
            this.data.Serialize(writer); /* composite */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Outputs object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += this.response.CalculateSize(); /* composite */
            size += this.data.CalculateSize(); /* composite */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Outputs to Deserialize instances
    /// </summary>
    public static class DeserOutputsExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Outputs instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Outputs DeserializeOutputs(BinaryReader reader)
        {
            return Outputs.Deserialize(reader); 
        }
    }

    /// <summary>
    /// FFI-safe wire representation for Outputs.
    /// Mirrors the Rust Wire&lt;Outputs&gt; structure layout.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct WireOfOutputs
    {
        /// <summary>Pointer to buffer data</summary>
        public byte* Data;

        /// <summary>Length of valid data in buffer</summary>
        public long Length;

        /// <summary>Capacity of buffer (0 for borrowed buffers)</summary>
        public long Capacity;

        /// <summary>
        /// Create a Wire from a managed Outputs object with owned buffer
        /// </summary>
        public static WireOfOutputs From(Outputs value)
        {
            var size = value.CalculateSize();
            var buffer = Marshal.AllocHGlobal(size);
            var wire = new WireOfOutputs
            {
                Data = (byte*)buffer,
                Length = (long)size,
                Capacity = (long)size
            };

            try
            {
                value.Serialize(wire.Writer());
                return wire;
            }
            catch
            {
                Marshal.FreeHGlobal(buffer);
                throw;
            }
        }

        /// <summary>
        /// Create a Wire from a managed Outputs object using provided buffer
        /// </summary>
        public static WireOfOutputs From(Outputs value, byte* buffer, int bufferSize)
        {
            var wire = new WireOfOutputs
            {
                Data = buffer,
                Length = 0,
                Capacity = 0 // Indicates borrowed buffer
            };

            var size = value.CalculateSize();
            if (size > bufferSize)
                throw new ArgumentException($"Buffer size {bufferSize} is too small for data size {size} when serializing Outputs");

            wire.Length = (long)size;
            value.Serialize(wire.Writer());
            return wire;
        }

        public BinaryReader Reader()
        {
            // UIntPtr Ptr = (UIntPtr)Data;
            // throw new ArgumentException($"Creating a reader for wire with {Length} bytes in it, {Ptr} ptr and {Capacity} capacity");
            var reader = new BinaryReader(new UnmanagedMemoryStream(Data, Length));
            return reader;
        }

        public BinaryWriter Writer()
        {
            var writer = new BinaryWriter(new UnmanagedMemoryStream(Data, Length, Length, FileAccess.Write));
            return writer;
        }

        /// <summary>
        /// Free the buffer if this wire owns it
        /// </summary>
        public void Dispose()
        {
            if (Data != null && IsOwned)
            {
                Marshal.FreeHGlobal((IntPtr)Data);
                Data = null;
                Length = 0;
                Capacity = 0;
            }
        }

        /// <summary>
        /// Check if this wire owns its buffer
        /// </summary>
        public bool IsOwned => Capacity > 0;

        /// <summary>
        /// Check if the wire buffer is empty
        /// </summary>
        public bool IsEmpty => Length == 0;

    }

    /// <summary>
    /// Extension methods for Outputs to create Wire instances
    /// </summary>
    public static class WireOfOutputsExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Outputs instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static WireOfOutputs Wire(this Outputs value)
        {
            return WireOfOutputs.From(value);
        }

        /// <summary>
        /// Create a Wire with borrowed buffer from this Outputs instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe WireOfOutputs WireWithBuffer(this Outputs value, byte* buffer, int bufferSize)
        {
            return WireOfOutputs.From(value, buffer, bufferSize);
        }

        /// <summary>
        /// Calculate the wire size needed for this Outputs instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static int WireSize(this Outputs value)
        {
            return value.CalculateSize();
        }

        /// <summary>
        /// Unwire a WireOfOutputs back to a managed Outputs object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Outputs Unwire(this WireOfOutputs wire)
        {
            return Outputs.Deserialize(wire.Reader());
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Response
    {
        /// 
        public Result[] results;

        /// <summary>Empty constructor</summary>
        public Response() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Response(Result[] results)
        {
            this.results = results;
        }

        public override string ToString()
        {
            return "Response { results = " + results + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Response object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Response Deserialize(BinaryReader reader)
        {
            return new Response {
                results = WireInterop.DeserializeVec<Result>(reader, DeserResultExtensions.DeserializeResult), /* vec */
                
            };

        }

        /// <summary>
        /// Serialize a Response object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            WireInterop.SerializeVec(writer, this.results); /* vec */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Response object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += WireInterop.CalculateVecSize(this.results); /* vec */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Response to Deserialize instances
    /// </summary>
    public static class DeserResponseExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Response instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Response DeserializeResponse(BinaryReader reader)
        {
            return Response.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Result
    {
        /// 
        public String item_id;
        /// 
        public int item_value;

        /// <summary>Empty constructor</summary>
        public Result() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Result(String item_id, int item_value)
        {
            this.item_id = item_id;
            this.item_value = item_value;
        }

        public override string ToString()
        {
            return "Result { item_id = " + item_id + ", item_value = " + item_value + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Result object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Result Deserialize(BinaryReader reader)
        {
            return new Result {
                item_id = WireInterop.DeserializeString(reader), /* string */
                
            item_value = reader.ReadInt32(),


            };

        }

        /// <summary>
        /// Serialize a Result object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            this.item_id.Serialize(writer); /* string */

            writer.Write((int)this.item_value);



        }

        /// <summary>
        /// Calculate the size needed to serialize a Result object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += 8 + System.Text.Encoding.UTF8.GetByteCount(this.item_id ?? ""); /* string */
            size += 4; /* primitive */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Result to Deserialize instances
    /// </summary>
    public static class DeserResultExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Result instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Result DeserializeResult(BinaryReader reader)
        {
            return Result.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class Table
    {
        /// 
        public TableMetadata metadata;
        /// 
        public byte[] byte_array;

        /// <summary>Empty constructor</summary>
        public Table() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Table(TableMetadata metadata, byte[] byte_array)
        {
            this.metadata = metadata;
            this.byte_array = byte_array;
        }

        public override string ToString()
        {
            return "Table { metadata = " + metadata + ", byte_array = " + byte_array + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Table object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Table Deserialize(BinaryReader reader)
        {
            return new Table {
                metadata = DeserTableMetadataExtensions.DeserializeTableMetadata(reader), /* composite */
                byte_array = WireInterop.DeserializeVecOfByte(reader), /* vec */
            };

        }

        /// <summary>
        /// Serialize a Table object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {

            this.metadata.Serialize(writer); /* composite */
            WireInterop.SerializeVec(writer, this.byte_array); /* vec */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Table object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += this.metadata.CalculateSize(); /* composite */
            size += WireInterop.CalculateVecSize(this.byte_array); /* vec */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for Table to Deserialize instances
    /// </summary>
    public static class DeserTableExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Table instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static Table DeserializeTable(BinaryReader reader)
        {
            return Table.Deserialize(reader); 
        }
    }

    /// <summary>
    /// Domain type that is sent across FFI boundary in a Wire.
    /// </summary>
    public partial class TableMetadata
    {
        /// 
        public int row_count;
        /// 
        public int column_count;
        /// 
        public String guid;
        /// 
        public String prefix;

        /// <summary>Empty constructor</summary>
        public TableMetadata() { }

        /// <summary>Member-wise initializing constructor</summary>
        public TableMetadata(int row_count, int column_count, String guid, String prefix)
        {
            this.row_count = row_count;
            this.column_count = column_count;
            this.guid = guid;
            this.prefix = prefix;
        }

        public override string ToString()
        {
            return "TableMetadata { row_count = " + row_count + ", column_count = " + column_count + ", guid = " + guid + ", prefix = " + prefix + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed TableMetadata object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TableMetadata Deserialize(BinaryReader reader)
        {
            return new TableMetadata {
                
            row_count = reader.ReadInt32(),


                
            column_count = reader.ReadInt32(),


                guid = WireInterop.DeserializeString(reader), /* string */
                prefix = WireInterop.DeserializeString(reader), /* string */
            };

        }

        /// <summary>
        /// Serialize a TableMetadata object into this wire's buffer
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Serialize(BinaryWriter writer)
        {


            writer.Write((int)this.row_count);



            writer.Write((int)this.column_count);


            this.guid.Serialize(writer); /* string */
            this.prefix.Serialize(writer); /* string */

        }

        /// <summary>
        /// Calculate the size needed to serialize a TableMetadata object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public int CalculateSize()
        {

            int size = 0;
            size += 4; /* primitive */
            size += 4; /* primitive */
            size += 8 + System.Text.Encoding.UTF8.GetByteCount(this.guid ?? ""); /* string */
            size += 8 + System.Text.Encoding.UTF8.GetByteCount(this.prefix ?? ""); /* string */

            return size;

        }
    }

    /// <summary>
    /// Extension methods for TableMetadata to Deserialize instances
    /// </summary>
    public static class DeserTableMetadataExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this TableMetadata instance
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static TableMetadata DeserializeTableMetadata(BinaryReader reader)
        {
            return TableMetadata.Deserialize(reader); 
        }
    }

    public enum ItemKey
    {

        TOTAL = 0,

        FIRST = 1,

        SECOND = 2,

        THIRD = 3,

    }

    public static class WireItemKeyExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static void Serialize(this ItemKey value, BinaryWriter writer) {
            writer.Write((int)value); /* only works for unit enum variants */
        }
    }



}
