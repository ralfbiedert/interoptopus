pub(crate) mod builtins;
pub(crate) mod class;
pub(crate) mod constants;
pub(crate) mod docs;
pub(crate) mod functions;
pub(crate) mod imports;
pub(crate) mod namespace;
pub(crate) mod patterns;
pub(crate) mod types;

use crate::interop::builtins::write_builtins;
use crate::interop::class::{write_class_context, write_native_lib_string};
use crate::interop::constants::write_constants;
use crate::interop::docs::write_file_header_comments;
use crate::interop::functions::write_functions;
use crate::interop::imports::write_imports;
use crate::interop::namespace::write_namespace_context;
use crate::interop::patterns::abi_guard::write_abi_guard;
use crate::interop::patterns::write_patterns;
use crate::interop::types::write_type_definitions;
use derive_builder::Builder;
use interoptopus::lang::c::{CType, CompositeType, Constant, Function, Meta};
use interoptopus::patterns::TypePattern;
use interoptopus::util::{is_global_type, NamespaceMappings};
use interoptopus::writer::IndentWriter;
use interoptopus::{indented, Bindings, Error, Inventory};

/// How to convert from Rust function names to C#
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum FunctionNameFlavor<'a> {
    /// Takes the name as it is written in Rust
    RawFFIName,
    /// Converts the name to camel case
    CSharpMethodNameWithClass,
    /// Converts the name to camel case and removes the class name
    CSharpMethodNameWithoutClass(&'a str),
}

/// The types to write for the given recorder.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum WriteTypes {
    /// Only write items defined in the library for this namespace.
    Namespace,
    /// Write types in this namespace and global interoptopus types (e.g., `FFIBool`)
    NamespaceAndInteroptopusGlobal,
    /// Write every type in the library, regardless of namespace association.
    All,
}

/// How to handle generation of unsupported elements
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Unsupported {
    /// Emit a panic during binding generation.
    Panic,
    /// Try to finish binding generation. Unsupported items may be broken and a code comment is added.
    Comment,
}

impl WriteTypes {
    #[must_use]
    pub const fn write_interoptopus_globals(self) -> bool {
        match self {
            Self::Namespace => false,
            Self::NamespaceAndInteroptopusGlobal => true,
            Self::All => true,
        }
    }
}

/// The access modifiers for generated `CSharp` types
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Visibility {
    /// Mimics Rust visibility.
    AsDeclared,
    /// Generates all types as `public class` / `public struct`.
    ForcePublic,
    /// Generates all types as `internal class` / `internal struct`.
    ForceInternal,
}

impl Visibility {
    #[must_use]
    pub const fn to_access_modifier(self) -> &'static str {
        match self {
            // TODO: `AsDeclared` should ultimately use the declared visibility but for now copy the previous
            //        behavior which is to make everything public.
            Self::AsDeclared => "public",
            Self::ForcePublic => "public",
            Self::ForceInternal => "internal",
        }
    }
}

impl Default for Interop {
    fn default() -> Self {
        Self {
            inventory: Inventory::default(),
            file_header_comment: "// Automatically generated by Interoptopus.".to_string(),
            class: "Interop".to_string(),
            class_constants: None,
            dll_name: "library".to_string(),
            namespace_mappings: NamespaceMappings::new("My.Company"),
            namespace_id: String::new(),
            visibility_types: Visibility::AsDeclared,
            unroll_struct_arrays: false,
            write_types: WriteTypes::NamespaceAndInteroptopusGlobal,
            rename_symbols: false,
            debug: false,
            work_around_exception_in_callback_no_reentry: true,
            unsupported: Unsupported::Panic,
            error_text: "Something went wrong: {error}".to_string(),
        }
    }
}

/// Generates C# interop files, **get this with [`InteropBuilder`]**.üêô
#[derive(Clone, Debug, Builder)]
#[builder(default)]
#[allow(clippy::struct_excessive_bools)]
pub struct Interop {
    /// The file header, e.g., `// (c) My Company`.
    file_header_comment: String,
    /// Name of static class for Interop methods, e.g., `Interop`.
    class: String,
    /// Name of static class for Interop constants, e.g., `Interop`. If [None] then [Self.class] is used
    class_constants: Option<String>,
    /// DLL to load, e.g., `my_library`.
    dll_name: String,
    /// Maps which namespace id belongs into which FQN (e.g., "common" => "MyCompany.Common").
    namespace_mappings: NamespaceMappings,
    /// Namespace ID of _this_ namespace to write (default "").
    namespace_id: String,
    /// Sets the visibility access modifiers for generated types.
    pub(crate) visibility_types: Visibility,
    /// Whether, say, a `x: [u8; 3]` should become 3 `x0: u8, ...` instead.
    ///
    /// If this is not set, interop generation with arrays in structs will fail. This is a somewhat
    /// open issue w.r.t Unity-sans-unsafe support and feedback would be greatly welcome!
    unroll_struct_arrays: bool,
    /// Which types to write.
    write_types: WriteTypes,
    /// Generate functions and field names matching C# conventions, instead of mapping them 1:1 with Rust.
    pub(crate) rename_symbols: bool,
    /// Also generate markers for easier debugging
    debug: bool,
    /// Whether we should attempt to work around issues where a callback back to C# might not
    /// reenter Rust code when an exception happened. This requires callbacks to return
    /// an `FFIError` type.
    work_around_exception_in_callback_no_reentry: bool,
    /// How to handle unsupported constructs.
    unsupported: Unsupported,
    /// The string to use for reporting within `FFIError`. Use `{error}` to reference the inner error content.
    error_text: String,
    pub(crate) inventory: Inventory,
}

#[allow(clippy::unused_self)]
impl Interop {
    fn debug(&self, w: &mut IndentWriter, marker: &str) -> Result<(), Error> {
        if !self.debug {
            return Ok(());
        }

        indented!(w, r"// Debug - {} ", marker)
    }

    #[must_use]
    fn namespace_for_id(&self, id: &str) -> String {
        self.namespace_mappings
            .get(id)
            .unwrap_or_else(|| panic!("Found a namespace not mapped '{id}'. You should specify this one in the config."))
            .to_string()
    }

    #[must_use]
    #[allow(dead_code)] // TODO?
    fn should_emit_delegate(&self) -> bool {
        match self.write_types {
            WriteTypes::Namespace => false,
            WriteTypes::NamespaceAndInteroptopusGlobal => self.namespace_id.is_empty(),
            WriteTypes::All => true,
        }
    }

    fn should_emit_marshaller_for_composite(&self, composite: &CompositeType) -> bool {
        composite
            .fields()
            .iter()
            .any(|f| matches!(f.the_type(), CType::Composite(_)) || self.should_emit_marshaller(f.the_type()))
    }

    fn should_emit_marshaller(&self, ctype: &CType) -> bool {
        match ctype {
            CType::Array(_) => !self.unroll_struct_arrays,
            CType::Composite(x) => self.should_emit_marshaller_for_composite(x),
            _ => false,
        }
    }

    #[allow(dead_code)]
    fn has_emittable_marshallers(&self, types: &[CType]) -> bool {
        types.iter().any(|x| self.should_emit_marshaller(x))
    }

    fn has_emittable_functions(&self, functions: &[Function]) -> bool {
        functions.iter().any(|x| self.should_emit_by_meta(x.meta()))
    }

    #[must_use]
    fn has_emittable_constants(&self, constants: &[Constant]) -> bool {
        constants.iter().any(|x| self.should_emit_by_meta(x.meta()))
    }

    fn has_ffi_error(&self, functions: &[Function]) -> bool {
        functions.iter().any(interoptopus::lang::c::Function::returns_ffi_error)
    }

    #[must_use]
    fn should_emit_by_meta(&self, meta: &Meta) -> bool {
        let rval = meta.namespace() == self.namespace_id;
        rval
    }

    /// Checks whether for the given type and the current file a type definition should be emitted.
    #[must_use]
    fn should_emit_by_type(&self, t: &CType) -> bool {
        if self.write_types == WriteTypes::All {
            return true;
        }

        if is_global_type(t) {
            return self.write_types == WriteTypes::NamespaceAndInteroptopusGlobal;
        }

        match t {
            CType::Primitive(_) => self.write_types == WriteTypes::NamespaceAndInteroptopusGlobal,
            CType::Array(_) => false,
            CType::Enum(x) => self.should_emit_by_meta(x.meta()),
            CType::Opaque(x) => self.should_emit_by_meta(x.meta()),
            CType::Composite(x) => self.should_emit_by_meta(x.meta()),
            CType::FnPointer(_) => true,
            CType::ReadPointer(_) => false,
            CType::ReadWritePointer(_) => false,
            CType::Pattern(x) => match x {
                TypePattern::CStrPointer => true,
                TypePattern::APIVersion => true,
                TypePattern::FFIErrorEnum(x) => self.should_emit_by_meta(x.the_enum().meta()),
                TypePattern::Slice(x) => self.should_emit_by_meta(x.meta()),
                TypePattern::SliceMut(x) => self.should_emit_by_meta(x.meta()),
                TypePattern::Option(x) => self.should_emit_by_meta(x.meta()),
                TypePattern::Bool => self.write_types == WriteTypes::NamespaceAndInteroptopusGlobal,
                TypePattern::CChar => false,
                TypePattern::NamedCallback(x) => self.should_emit_by_meta(x.meta()),
                _ => panic!("Pattern not explicitly handled"),
            },
        }
    }

    fn write_all(&self, w: &mut IndentWriter) -> Result<(), Error> {
        write_file_header_comments(self, w)?;
        w.newline()?;

        write_imports(self, w)?;
        w.newline()?;

        write_namespace_context(self, w, |w| {
            if self.class_constants.is_none() || self.class_constants == Some(self.clone().class) {
                if self.has_emittable_functions(self.inventory.functions()) || self.has_emittable_constants(self.inventory.constants()) {
                    write_class_context(self, &self.class, w, |w| {
                        write_native_lib_string(self, w)?;
                        w.newline()?;

                        write_abi_guard(self, w)?;
                        w.newline()?;

                        write_constants(self, w)?;
                        w.newline()?;

                        write_functions(self, w)?;
                        Ok(())
                    })?;
                }
            } else {
                if self.has_emittable_constants(self.inventory.constants()) {
                    write_class_context(self, self.class_constants.as_ref().unwrap(), w, |w| {
                        write_constants(self, w)?;
                        w.newline()?;

                        Ok(())
                    })?;
                }

                if self.has_emittable_functions(self.inventory.functions()) {
                    w.newline()?;
                    write_class_context(self, &self.class, w, |w| {
                        write_native_lib_string(self, w)?;
                        w.newline()?;

                        write_abi_guard(self, w)?;
                        w.newline()?;

                        write_functions(self, w)?;
                        Ok(())
                    })?;
                }
            }

            w.newline()?;
            write_type_definitions(self, w)?;

            w.newline()?;
            write_patterns(self, w)?;

            w.newline()?;
            write_builtins(self, w)?;

            Ok(())
        })?;

        Ok(())
    }
}

impl Bindings for Interop {
    fn write_to(&self, w: &mut IndentWriter) -> Result<(), Error> {
        self.write_all(w)
    }
}

impl InteropBuilder {
    /// Creates a new builder instance, **start here**.
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }
}
