---
source: crates/proc_macros_impl/tests/ffi_unified.rs
expression: expand_ffi!(item)
---
#[unsafe(export_name = "test_function")]
pub extern "C" fn test_function(input: u32) -> u32 {
    input * 2
}
#[allow(non_camel_case_types)]
pub struct test_function {}
const _: () = const {
    ::interoptopus::lang::types::assert_raw_safe::<u32>();
};
const _: () = const {
    ::interoptopus::lang::types::assert_raw_safe::<u32>();
};
impl ::interoptopus::lang::function::FunctionInfo for test_function {
    fn id() -> ::interoptopus::inventory::FunctionId {
        ::interoptopus::inventory::FunctionId::from_id(
            ::interoptopus::id!(test_function),
        )
    }
    fn signature() -> ::interoptopus::lang::function::Signature {
        ::interoptopus::lang::function::Signature {
            arguments: vec![
                ::interoptopus::lang::function::Argument::new("input", < u32 as
                ::interoptopus::lang::types::TypeInfo > ::id())
            ],
            rval: <u32 as ::interoptopus::lang::types::TypeInfo>::id(),
        }
    }
    fn function() -> ::interoptopus::lang::function::Function {
        ::interoptopus::lang::function::Function {
            name: "test_function".to_string(),
            visibility: ::interoptopus::lang::meta::Visibility::Public,
            docs: ::interoptopus::lang::meta::Docs::from_lines(vec![]),
            emission: ::interoptopus::lang::meta::Emission::External,
            signature: Self::signature(),
        }
    }
    fn register(inventory: &mut ::interoptopus::inventory::Inventory) {
        <u32 as ::interoptopus::lang::types::TypeInfo>::register(inventory);
        <u32 as ::interoptopus::lang::types::TypeInfo>::register(inventory);
        inventory.register_function(Self::id(), Self::function());
    }
}
