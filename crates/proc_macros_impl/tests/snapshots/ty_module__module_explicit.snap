---
source: crates/proc_macros_impl/tests/ty_module.rs
expression: expand_ty!(item)
---
#[repr(C)]
struct Foo {
    x: u8,
}
impl ::interoptopus::lang::types::TypeInfo for Foo {
    const WIRE_SAFE: bool = <u8 as ::interoptopus::lang::types::TypeInfo>::WIRE_SAFE;
    const RAW_SAFE: bool = <u8 as ::interoptopus::lang::types::TypeInfo>::RAW_SAFE;
    const ASYNC_SAFE: bool = <u8 as ::interoptopus::lang::types::TypeInfo>::ASYNC_SAFE;
    const SERVICE_SAFE: bool = false;
    const SERVICE_CTOR_SAFE: bool = false;
    fn id() -> ::interoptopus::inventory::TypeId {
        ::interoptopus::inventory::TypeId::from_id(::interoptopus::id!(Foo))
    }
    fn kind() -> ::interoptopus::lang::types::TypeKind {
        ::interoptopus::lang::types::TypeKind::Struct(::interoptopus::lang::types::Struct {
            fields: vec![
                ::interoptopus::lang::types::Field { name : "x".to_string(), docs :
                ::interoptopus::lang::meta::Docs::from_line(""), visibility :
                ::interoptopus::lang::meta::Visibility::Public, ty : < u8 as
                ::interoptopus::lang::types::TypeInfo > ::id(), }
            ],
            repr: ::interoptopus::lang::types::Repr {
                layout: ::interoptopus::lang::types::Layout::C,
                alignment: None,
            },
        })
    }
    fn ty() -> ::interoptopus::lang::types::Type {
        ::interoptopus::lang::types::Type {
            name: "Foo".to_string(),
            visibility: ::interoptopus::lang::meta::Visibility::Public,
            docs: ::interoptopus::lang::meta::Docs::from_line(""),
            emission: ::interoptopus::lang::meta::Emission::Module("foo".to_string()),
            kind: Self::kind(),
        }
    }
    fn register(inventory: &mut ::interoptopus::inventory::Inventory) {
        <u8 as ::interoptopus::lang::types::TypeInfo>::register(inventory);
        inventory.register_type(Self::id(), Self::ty());
    }
}
