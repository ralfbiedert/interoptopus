// <auto-generated>
//
// This file was automatically generated by Interoptopus.
//
// Library:      library
// Hash:         0xc0edfcadb6ee3e2f
// Namespace:    
// Builder:      interoptopus_backend_csharp (0.15.0-alpha.17)
//
// Do not edit this file manually.
//
// </auto-generated>

#pragma warning disable 0105
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Runtime.CompilerServices;
using My.Company;
#pragma warning restore 0105

namespace My.Company
{
    public static partial class Interop
    {
        public const string NativeLib = "library";

        static Interop()
        {
        }



        [LibraryImport(NativeLib, EntryPoint = "concat")]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Utf8String concat(WireOfFields input, CsharpCallback callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Utf8String concat(WireOfFields input, CsharpCallbackDelegate callback)
        {
            var callback_wrapped = new CsharpCallback(callback);
            try
            {
                return concat(input, callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

    }

    ///FFI buffer for Wire data transfer
    public partial struct WireBuffer
    {
        public IntPtr data;
        public int len;
        public int capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct WireBuffer 
    {
        public WireBuffer() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.data = data;
            _unmanaged.len = len;
            _unmanaged.capacity = capacity;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.data = data;
            _unmanaged.len = len;
            _unmanaged.capacity = capacity;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr data;
            public int len;
            public int capacity;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe WireBuffer ToManaged()
            {
                var _managed = new WireBuffer();
                _managed.data = data;
                _managed.len = len;
                _managed.capacity = capacity;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "WireBuffer { ... }";
        }

        [CustomMarshaller(typeof(WireBuffer), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private WireBuffer _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(WireBuffer managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(WireBuffer managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public WireBuffer ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }


    public partial class Fields
    {
        /// 
        public String name;
        /// 
        public Dictionary<String, Pair> attrs;
    }

    public partial class Fields
    {
        /// <summary>Empty constructor</summary>
        public Fields() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Fields(String name, Dictionary<String, Pair> attrs)
        {
            this.name = name;
            this.attrs = attrs;
        }

        public override string ToString()
        {
            return "Fields { name = " + name + ", attrs = " + attrs + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Fields object
        /// </summary>
        public static Fields Deserialize(BinaryReader reader)
        {
            return new Fields {
                name = WireInterop.DeserializeString(reader), /* string */
                
                attrs = WireInterop.DeserializeMap<String, Pair>(reader, WireInterop.DeserializeString, SerdePairExtensions.DeserializePair), /* map */
            };

        }

        /// <summary>
        /// Serialize a Fields object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.name.Serialize(writer); /* string */

            WireInterop.SerializeMap(writer, this.attrs, WireInterop.SerializeString, SerdePairExtensions.SerializePair); /* map */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Fields object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(this.name ?? "") /* string */

                + 

            WireInterop.CalculateVariableMapSize(this.attrs, SerdeStringExtensions.CalculateSize, SerdePairExtensions.CalculateSize) /* map */

            ;

        }
    }

    /// <summary>
    /// Extension methods for Fields to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeFieldsExtensions
    {
        public static void SerializeFields(BinaryWriter writer, Fields item)
        {
            item.Serialize(writer); 
        }

        public static Fields DeserializeFields(BinaryReader reader)
        {
            return Fields.Deserialize(reader); 
        }

        public static int CalculateSize(Fields value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// FFI-safe wire representation for Fields.
    /// Mirrors the Rust Wire&lt;Fields&gt; structure layout.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct WireOfFields
    {
        /// <summary>Pointer to buffer data</summary>
        byte* Data;

        /// <summary>Length of valid data in buffer</summary>
        int Length;

        /// <summary>
        /// Encoded capacity: 0=borrowed, >0=Rust-allocated, <0=C#-allocated (abs value = actual capacity)
        /// </summary>
        int Capacity;
    }

    /// <summary>
    /// FFI-safe wire representation for Fields.
    /// Mirrors the Rust Wire&lt;Fields&gt; structure layout.
    /// </summary>
    public unsafe partial struct WireOfFields
    {
        /// <summary>
        /// Create a Wire from a managed Fields object with owned buffer
        /// </summary>
        public static WireOfFields From(Fields value)
        {
            var size = value.CalculateSize();
            var buffer = Marshal.AllocHGlobal(size);
            var wire = new WireOfFields
            {
                Data = (byte*)buffer,
                Length = (int)size,
                Capacity = -(int)size
            };

            try
            {
                value.Serialize(wire.Writer());
                return wire;
            }
            catch
            {
                Marshal.FreeHGlobal(buffer);
                throw;
            }
        }

        /// <summary>
        /// Create a Wire from a managed Fields object using provided buffer
        /// </summary>
        public static WireOfFields From(Fields value, byte* buffer, int bufferSize)
        {
            var size = value.CalculateSize();
            if (size > bufferSize)
                throw new ArgumentException($"Buffer size {bufferSize} is too small for data size {size} when serializing Fields");

            var wire = new WireOfFields
            {
                Data = buffer,
                Length = (int)size,
                Capacity = 0 // Indicates borrowed buffer
            };

            value.Serialize(wire.Writer());
            return wire;
        }

        public BinaryReader Reader()
        {
            // UIntPtr Ptr = (UIntPtr)Data;
            // throw new ArgumentException($"Creating a reader for wire with {Length} bytes in it, {Ptr} ptr and {Capacity} capacity");
            var reader = new BinaryReader(new UnmanagedMemoryStream(Data, Length));
            return reader;
        }

        public BinaryWriter Writer()
        {
            var writer = new BinaryWriter(new UnmanagedMemoryStream(Data, Length, Length, FileAccess.Write));
            return writer;
        }

        /// <summary>
        /// Free the buffer if this wire owns it
        /// </summary>
        public void Dispose()
        {
            if (Data != null)
            {
                if (IsOwned) {
                    if (Capacity > 0) {
                        WireInterop.interoptopus_wire_destroy((IntPtr)Data, Length, Capacity);
                    } else {
                        Marshal.FreeHGlobal((IntPtr)Data);
                    }
                }
                Data = null;
                Length = 0;
                Capacity = 0;
            }
        }

        /// <summary>
        /// Check if this wire owns its buffer
        /// </summary>
        public bool IsOwned => Capacity != 0;

        /// <summary>
        /// Check if the wire buffer is empty
        /// </summary>
        public bool IsEmpty => Length == 0;
    }

    /// <summary>
    /// Extension methods for Fields to create Wire instances
    /// </summary>
    public static class WireOfFieldsExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this Fields instance
        /// </summary>
        public static WireOfFields Wire(this Fields value)
        {
            return WireOfFields.From(value);
        }

        /// <summary>
        /// Create a Wire with borrowed buffer from this Fields instance
        /// </summary>
        public static unsafe WireOfFields WireWithBuffer(this Fields value, byte* buffer, int bufferSize)
        {
            return WireOfFields.From(value, buffer, bufferSize);
        }

        /// <summary>
        /// Calculate the wire size needed for this Fields instance
        /// </summary>
        public static int WireSize(this Fields value)
        {
            return value.CalculateSize();
        }

        /// <summary>
        /// Unwire a WireOfFields back to a managed Fields object
        /// </summary>
        public static Fields Unwire(this WireOfFields wire)
        {
            return Fields.Deserialize(wire.Reader());
        }
    }


    public partial class Pair
    {
        /// 
        public uint key;
        /// 
        public String? value;
    }

    public partial class Pair
    {
        /// <summary>Empty constructor</summary>
        public Pair() { }

        /// <summary>Member-wise initializing constructor</summary>
        public Pair(uint key, String? value)
        {
            this.key = key;
            this.value = value;
        }

        public override string ToString()
        {
            return "Pair { key = " + key + ", value = " + value + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed Pair object
        /// </summary>
        public static Pair Deserialize(BinaryReader reader)
        {
            return new Pair {
                
            key = reader.ReadUInt32(),


                value = WireInterop.DeserializeOptional(reader, WireInterop.DeserializeString), /* optional */
            };

        }

        /// <summary>
        /// Serialize a Pair object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {


            writer.Write(this.key);


            WireInterop.SerializeOptional<String>(writer, this.value, WireInterop.SerializeString);  /* optional */

        }

        /// <summary>
        /// Calculate the size needed to serialize a Pair object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            4 /* primitive */

                + 
            1 + (this.value != null ? Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(this.value ?? "") : 0) /* optional */


            ;

        }
    }

    /// <summary>
    /// Extension methods for Pair to Serialize/Deserialize instances
    /// </summary>
    public static class SerdePairExtensions
    {
        public static void SerializePair(BinaryWriter writer, Pair item)
        {
            item.Serialize(writer); 
        }

        public static Pair DeserializePair(BinaryReader reader)
        {
            return Pair.Deserialize(reader); 
        }

        public static int CalculateSize(Pair value)
        {
            return value.CalculateSize(); 
        }
    }

    public partial class SliceU8
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceU8 : IEnumerable<byte>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<byte> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe byte this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()));
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceU8() { }

        public static SliceU8 From(IntPtr data, ulong len)
        {
            var rval = new SliceU8();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceU8 From(byte[] managed)
        {
            var rval = new SliceU8();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceU8 ToManaged()
            {
                return SliceU8.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceU8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceU8 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceU8Extensions
        {
            public static SliceU8 Slice(this byte[] s) { return SliceU8.From(s); }
        }


    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void CsharpCallbackNative(SliceU8.Unmanaged result, IntPtr callback_data); // 'True' native callback signature
    public delegate void CsharpCallbackDelegate(SliceU8 result); // Our C# signature

    public partial class CsharpCallback
    {
        private CsharpCallbackDelegate _managed; // C# callback
        private CsharpCallbackNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class CsharpCallback : IDisposable
    {

        internal CsharpCallback() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public CsharpCallback(CsharpCallbackDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(SliceU8.Unmanaged result, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(result.ToManaged());
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(SliceU8 result)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<CsharpCallbackNative>(_ptr);
            // TODO
            // __target(result.ToManaged());
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(CsharpCallback), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public CsharpCallback ToManaged()
            {
                var rval = new CsharpCallback();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private CsharpCallback _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CsharpCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CsharpCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CsharpCallback ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }



    public class InteropException : Exception
    {
        public InteropException() : base()
        {
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void AsyncHelperNative(IntPtr data, IntPtr callback_data);
    public delegate void AsyncHelperDelegate(IntPtr data);

    public partial struct AsyncHelper
    {
        private AsyncHelperDelegate _managed;
        private AsyncHelperNative _native;
        private IntPtr _ptr;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct AsyncHelper : IDisposable
    {
        public AsyncHelper() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public AsyncHelper(AsyncHelperDelegate managed)
        {
            _managed = managed;
            _native = Call;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        void Call(IntPtr data, IntPtr _)
        {
            _managed(data);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            Marshal.FreeHGlobal(_ptr);
            _ptr = IntPtr.Zero;
        }

        [CustomMarshaller(typeof(AsyncHelper), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr Callback;
            internal IntPtr Data;
        }

        public ref struct Marshaller
        {
            private AsyncHelper _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(AsyncHelper managed) { _managed = managed; }
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Callback = _managed._ptr;
                _unmanaged.Data = IntPtr.Zero;
                return _unmanaged;
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public AsyncHelper ToManaged()
            {
                _managed = new AsyncHelper();
                _managed._ptr = _unmanaged.Callback;
                return _managed;
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() { }
        }
    }

    public delegate void AsyncCallbackCommon(IntPtr data, IntPtr callback_data);

    [StructLayout(LayoutKind.Sequential)]
    public partial struct AsyncCallbackCommonNative
    {
        internal IntPtr _ptr;
        internal IntPtr _ts;
    }
    public partial class Utf8String
    {
        IntPtr _ptr;
        ulong _len;
        ulong _capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class Utf8String : IDisposable
    {
        private Utf8String() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Utf8String From(string s)
        {
            var rval = new Utf8String();
            var source = s.AsSpan();
            Span<byte> utf8Bytes = stackalloc byte[Encoding.UTF8.GetByteCount(source)];
            var len = Encoding.UTF8.GetBytes(source, utf8Bytes);

            fixed (byte* p = utf8Bytes)
            {
                InteropHelper.interoptopus_string_create((IntPtr)p, (ulong)len, out var native);
                rval._ptr = native._ptr;
                rval._len = native._len;
                rval._capacity = native._capacity;
            }

            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Utf8String Empty()
        {
            InteropHelper.interoptopus_string_create(IntPtr.Zero, 0, out var _out);
            return _out.IntoManaged();
        }


        public unsafe string String
        {
            get
            {
                var span = new ReadOnlySpan<byte>((byte*)_ptr, (int)_len);
                var s = Encoding.UTF8.GetString(span);
                return s;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public string IntoString()
        {
            var rval = String;
            Dispose();
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            InteropHelper.interoptopus_string_destroy(_unmanaged);
            _ptr = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Utf8String Clone()
        {
            var _new = new Unmanaged();
            var _this = AsUnmanaged();
            InteropHelper.interoptopus_string_clone(ref _this, ref _new);
            return _new.IntoManaged();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged IntoUnmanaged()
        {
            if (_ptr == IntPtr.Zero) { throw new Exception(); }
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            _ptr = IntPtr.Zero;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr _ptr;
            public ulong _len;
            public ulong _capacity;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Utf8String IntoManaged()
            {
                var _managed = new Utf8String();
                _managed._ptr = _ptr;
                _managed._len = _len;
                _managed._capacity = _capacity;
                return _managed;
            }

        }

        public partial class InteropHelper
        {
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_create")]
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            
            public static partial long interoptopus_string_create(IntPtr utf8, ulong len, out Unmanaged rval);

            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_destroy")]
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            
            public static partial long interoptopus_string_destroy(Unmanaged utf8);

            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_clone")]
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            
            public static partial long interoptopus_string_clone(ref Unmanaged orig, ref Unmanaged cloned);
        }

        [CustomMarshaller(typeof(Utf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private Utf8String _managed; // Used when converting managed -> unmanaged
            private Unmanaged _unmanaged; // Used when converting unmanaged -> managed

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Utf8String managed) { _managed = managed; }
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Utf8String managed) { _managed = managed; }
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public unsafe Unmanaged ToUnmanaged()
            {
                return _managed.IntoUnmanaged();
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public unsafe Utf8String ToManaged()
            {
                return _unmanaged.IntoManaged();
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() { }
        }
    }

    public static class StringExtensions
    {
        public static Utf8String Utf8(this string s) { return Utf8String.From(s); }
    }

    public partial class WireInterop {
        [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_wire_destroy")]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void interoptopus_wire_destroy(IntPtr data, int len, int capacity);

        #region Serialization Helpers
        #nullable enable

        public static void SerializeString(BinaryWriter writer, string value)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            var bytes = Encoding.UTF8.GetBytes(value);
            writer.Write((ulong)bytes.Length);
            writer.Write(bytes);
        }

        public static string DeserializeString(BinaryReader reader)
        {
            var length = reader.ReadUInt64();
            if (length == 0)
                return string.Empty;

            var bytes = reader.ReadBytes((int)length);
            return Encoding.UTF8.GetString(bytes);
        }

        public static void SerializeVecOfByte(BinaryWriter writer, byte[] vec)
        {
            writer.Write((ulong)vec.Length);
            writer.Write(vec);
        }

        public static void SerializeVec<T>(BinaryWriter writer, IList<T> value, Action<BinaryWriter, T> serializeItem)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            writer.Write((ulong)value.Count);
            foreach (var item in value)
            {
                serializeItem(writer, item);
            }
        }

        public static byte[] DeserializeVecOfByte(BinaryReader reader)
        {
            var length = reader.ReadUInt64();
            return reader.ReadBytes((int)length);
        }

        public static T[] DeserializeVec<T>(BinaryReader reader, Func<BinaryReader, T> deserializeItem)
        {
            var length = reader.ReadUInt64();
            var result = new T[(int)length];

            for (ulong i = 0; i < length; i++)
            {
                result[i] = deserializeItem(reader);
            }

            return result;
        }

        public static void SerializeMap<K,V>(BinaryWriter writer, IDictionary<K,V> value, Action<BinaryWriter, K> serializeKey, Action<BinaryWriter, V> serializeValue)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            writer.Write((ulong)value.Count);
            foreach (var item in value)
            {
                serializeKey(writer, item.Key);
                serializeValue(writer, item.Value);
            }
        }

        public static Dictionary<K,V> DeserializeMap<K,V>(BinaryReader reader, Func<BinaryReader, K> deserializeKey, Func<BinaryReader, V> deserializeValue)
        {
            var length = reader.ReadUInt64();
            var result = new Dictionary<K,V>((int)length);

            for (ulong i = 0; i < length; i++)
            {
                var k = deserializeKey(reader);
                var v = deserializeValue(reader);
                result.Add(k, v);
            }

            return result;
        }

        public static void SerializeOptional<T>(BinaryWriter writer, T? value, Action<BinaryWriter, T> serializeItem)
        {
            if (value != null)
            {
                writer.Write((byte)1);
                serializeItem(writer, value);
            }
            else
            {
                writer.Write((byte)0);
            }
        }

        #nullable enable
        public static T? DeserializeOptional<T>(BinaryReader reader, Func<BinaryReader, T> deserializeValue)
        {
            var hasValue = reader.ReadByte() != 0;
            if (hasValue)
            {
                return deserializeValue(reader);
            }
            return default;
        }
        #nullable restore

        public static T? DeserializeEnum<T>(BinaryReader reader) where T: System.Enum
        {
            var discriminant = reader.ReadInt32();
            if (Enum.IsDefined(typeof(T), discriminant))
            {
                return (T)Enum.ToObject(typeof(T), discriminant);
            }
            return default(T);
        }

        public static int CalculateVariableMapSize<K,V>(IDictionary<K,V> value, Func<K, int> calculateKeySize, Func<V, int> calculateValueSize)
        {
            int size = Marshal.SizeOf<ulong>(); // length field
            if (value == null) return size;

            foreach (var item in value)
            {
                size +=
                    calculateKeySize(item.Key)
                    + calculateValueSize(item.Value);}
            return size;
        }

        /// This method is called only for non-primitive inner types which require size calculations.
        public static int CalculateVariableVecSize<T>(IList<T> value, Func<T, int> calculateItemSize)
        {
            int size = Marshal.SizeOf<ulong>(); // length field
            if (value == null) return size;foreach (var item in value)
            {
                size += calculateItemSize(item);
            }
            return size;
        }

        #nullable restore
        #endregion
    }

    public static class SerdeStringExtensions
    {
        public static void Serialize(this String value, BinaryWriter writer) {
            WireInterop.SerializeString(writer, value);
        }

        public static String DeserializeString(BinaryReader reader) {
            return WireInterop.DeserializeString(reader);
        }

        public static int CalculateSize(String value) {
            return Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(value ?? "");
        }
    }
}
