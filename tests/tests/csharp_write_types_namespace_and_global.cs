// <auto-generated>
//
// This file was automatically generated by Interoptopus.
//
// Library:      library
// Hash:         0xa3db58f4c8a9a09d
// Namespace:    
// Builder:      interoptopus_backend_csharp (0.15.0-alpha.17)
//
// Do not edit this file manually.
//
// </auto-generated>

#pragma warning disable 0105
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Runtime.CompilerServices;
using My.Company;
using My.Company.Common;
#pragma warning restore 0105

namespace My.Company
{
    public static partial class Interop
    {
        public const string NativeLib = "library";

        static Interop()
        {
            var api_version = Interop.pattern_api_guard();
            if (api_version != 0xa3db58f4c8a9a09d)
            {
                throw new TypeLoadException($"API reports hash 0x{api_version:X} which differs from hash in bindings (0xa3db58f4c8a9a09d). You probably forgot to update / copy either the bindings or the library.");
            }
        }

        internal static AsyncTrampolineResultError _trampolineResultError = new();
        internal static AsyncTrampolineResultNestedArrayError _trampolineResultNestedArrayError = new();
        internal static AsyncTrampolineResultU64Error _trampolineResultU64Error = new();
        internal static AsyncTrampolineResultUseStringError _trampolineResultUseStringError = new();
        internal static AsyncTrampolineResultUtf8StringError _trampolineResultUtf8StringError = new();
        internal static AsyncTrampolineResultVecUtf8StringError _trampolineResultVecUtf8StringError = new();

        public const byte U8 = (byte) 255;

        public const float F32_MIN_POSITIVE = (float) 0.000000000000000000000000000000000000011754944;

        public const int COMPUTED_I32 = (int) -2147483647;


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_string_create")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_string_create(IntPtr utf8, ulong len, ref Utf8String rval);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_string_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_string_destroy(Utf8String utf8);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_string_clone")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_string_clone(ref Utf8String utf8, ref Utf8String rval);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_wire_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void interoptopus_wire_destroy(ref byte data, int len, int capacity);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_create_6849152863081469284")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_create_6849152863081469284(IntPtr data, ulong len, ref VecU8 rval);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_destroy_9353420175730321243")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_destroy_9353420175730321243(VecU8 ignored);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_create_17163327104750939811")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_create_17163327104750939811(IntPtr data, ulong len, ref VecUtf8String rval);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_destroy_13145557392013674812")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_destroy_13145557392013674812(VecUtf8String ignored);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_create_1781563852271199874")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_create_1781563852271199874(IntPtr data, ulong len, ref VecVec3f32 rval);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_destroy_12107015372467426116")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_destroy_12107015372467426116(VecVec3f32 ignored);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_create_12058709700293828778")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_create_12058709700293828778(IntPtr data, ulong len, ref VecEnumPayload rval);


        [LibraryImport(NativeLib, EntryPoint = "interoptopus_vec_destroy_4854562680055612543")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long interoptopus_vec_destroy_4854562680055612543(VecEnumPayload ignored);


        [LibraryImport(NativeLib, EntryPoint = "alignment_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Packed2 alignment_1(Packed1 a);


        [LibraryImport(NativeLib, EntryPoint = "array_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte array_1(Array x);


        [LibraryImport(NativeLib, EntryPoint = "array_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Array array_2();


        [LibraryImport(NativeLib, EntryPoint = "array_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void array_3(ref Array arr);


        [LibraryImport(NativeLib, EntryPoint = "char_array_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial CharArray char_array_1();


        [LibraryImport(NativeLib, EntryPoint = "char_array_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial CharArray char_array_2(CharArray arr);


        [LibraryImport(NativeLib, EntryPoint = "char_array_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte char_array_3(ref CharArray arr);


        [LibraryImport(NativeLib, EntryPoint = "nested_array_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial NestedArray nested_array_1();


        [LibraryImport(NativeLib, EntryPoint = "nested_array_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void nested_array_2(ref NestedArray result);


        [LibraryImport(NativeLib, EntryPoint = "nested_array_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte nested_array_3(NestedArray input);


        [LibraryImport(NativeLib, EntryPoint = "behavior_sleep")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void behavior_sleep(ulong millis);


        [LibraryImport(NativeLib, EntryPoint = "behavior_panics")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void behavior_panics();


        [LibraryImport(NativeLib, EntryPoint = "behavior_panics_via_result")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError behavior_panics_via_result();


        [LibraryImport(NativeLib, EntryPoint = "enums_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void enums_1(EnumPayload ignored);


        [LibraryImport(NativeLib, EntryPoint = "enums_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial EnumPayload enums_2(EnumPayload x);


        [LibraryImport(NativeLib, EntryPoint = "enums_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr enums_3(ref EnumPayload x);


        [LibraryImport(NativeLib, EntryPoint = "enums_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Utf8String enums_4(Layer3 x);


        [LibraryImport(NativeLib, EntryPoint = "fnptr_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte fnptr_1(InteropDelegate_fn_u8_rval_u8 callback, byte x);


        [LibraryImport(NativeLib, EntryPoint = "fnptr_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void fnptr_2(InteropDelegate_fn_CharArray_rval_void_native callback, CharArray x);


        [LibraryImport(NativeLib, EntryPoint = "generic_1a")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint generic_1a(Genericu32 x, Phantomu8 y);


        [LibraryImport(NativeLib, EntryPoint = "generic_1b")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte generic_1b(Genericu8 x, Phantomu8 y);


        [LibraryImport(NativeLib, EntryPoint = "generic_1c")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte generic_1c(ref Genericu8 x, ref Genericu8 y);


        [LibraryImport(NativeLib, EntryPoint = "generic_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte generic_2(IntPtr x);


        [LibraryImport(NativeLib, EntryPoint = "generic_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte generic_3(IntPtr x);


        [LibraryImport(NativeLib, EntryPoint = "generic_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte generic_4(IntPtr x);


        [LibraryImport(NativeLib, EntryPoint = "generic_5")]
        [return: MarshalAs(UnmanagedType.U1)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial bool generic_5(Weird1u32 x, Weird2u8 y);


        [LibraryImport(NativeLib, EntryPoint = "meta_ambiguous_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Vec1 meta_ambiguous_1(Vec1 x);


        [LibraryImport(NativeLib, EntryPoint = "meta_ambiguous_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Vec2 meta_ambiguous_2(Vec2 x);


        [LibraryImport(NativeLib, EntryPoint = "meta_ambiguous_3")]
        [return: MarshalAs(UnmanagedType.U1)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial bool meta_ambiguous_3(Vec1 x, Vec2 y);


        /// This function has documentation.
        [LibraryImport(NativeLib, EntryPoint = "meta_documented")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial EnumDocumented meta_documented(StructDocumented x);


        [LibraryImport(NativeLib, EntryPoint = "meta_visibility1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void meta_visibility1(Visibility1 x, Visibility2 y);


        [LibraryImport(NativeLib, EntryPoint = "meta_renamed")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial EnumRenamed meta_renamed(StructRenamed x);


        [LibraryImport(NativeLib, EntryPoint = "namespaced_inner_option")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial OptionVec namespaced_inner_option(OptionVec x);


        [LibraryImport(NativeLib, EntryPoint = "namespaced_inner_slice")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial SliceVec namespaced_inner_slice(SliceVec x);


        [LibraryImport(NativeLib, EntryPoint = "namespaced_inner_slice_mut")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial SliceMutVec namespaced_inner_slice_mut(SliceMutVec x);


        [LibraryImport(NativeLib, EntryPoint = "namespaced_type")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Vec namespaced_type(Vec x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_args_5")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long primitive_args_5(long x0, long x1, long x2, long x3, long x4);


        [LibraryImport(NativeLib, EntryPoint = "primitive_args_10")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long primitive_args_10(long x0, long x1, long x2, long x3, long x4, long x5, long x6, long x7, long x8, long x9);


        [LibraryImport(NativeLib, EntryPoint = "primitive_bool")]
        [return: MarshalAs(UnmanagedType.U1)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial bool primitive_bool([MarshalAs(UnmanagedType.U1)] bool x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_f32")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial float primitive_f32(float x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_f64")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial double primitive_f64(double x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_i16")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial short primitive_i16(short x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_i32")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial int primitive_i32(int x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_i64")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial long primitive_i64(long x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_i8")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial sbyte primitive_i8(sbyte x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_u16")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ushort primitive_u16(ushort x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_u32")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint primitive_u32(uint x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_u64")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ulong primitive_u64(ulong x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_usize")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial nuint primitive_usize(nuint x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_isize")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial nint primitive_isize(nint x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_u8")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte primitive_u8(byte x);


        [LibraryImport(NativeLib, EntryPoint = "primitive_void")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void primitive_void();


        [LibraryImport(NativeLib, EntryPoint = "primitive_void2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void primitive_void2();


        [LibraryImport(NativeLib, EntryPoint = "ptr1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr ptr1(ref long x);


        [LibraryImport(NativeLib, EntryPoint = "ptr2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr ptr2(ref IntPtr x);


        /// # Safety
        ///
        /// Parameter x must point to valid data.
        [LibraryImport(NativeLib, EntryPoint = "ptr3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr ptr3(ref long x);


        [LibraryImport(NativeLib, EntryPoint = "ref1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr ref1(ref long x);


        [LibraryImport(NativeLib, EntryPoint = "ref2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr ref2(ref long x);


        [LibraryImport(NativeLib, EntryPoint = "ref3")]
        [return: MarshalAs(UnmanagedType.U1)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial bool ref3(ref long x);


        [LibraryImport(NativeLib, EntryPoint = "ref4")]
        [return: MarshalAs(UnmanagedType.U1)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial bool ref4(ref long x);


        [LibraryImport(NativeLib, EntryPoint = "ref5")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void ref5(ref EnumPayload x);


        [LibraryImport(NativeLib, EntryPoint = "ref6")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void ref6(ref OptionEnumPayload x);


        [LibraryImport(NativeLib, EntryPoint = "ref7")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void ref7(ref VecUtf8String x);


        [LibraryImport(NativeLib, EntryPoint = "struct1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Tupled struct1(Tupled x);


        [LibraryImport(NativeLib, EntryPoint = "struct2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError struct2(Vec3f32 a, ref Tupled b);


        [LibraryImport(NativeLib, EntryPoint = "struct3")]
        [return: MarshalAs(UnmanagedType.U1)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial bool struct3(BoolField x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ascii_pointer_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint pattern_ascii_pointer_1([MarshalAs(UnmanagedType.LPStr)] string x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ascii_pointer_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr pattern_ascii_pointer_2();


        [LibraryImport(NativeLib, EntryPoint = "pattern_ascii_pointer_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr pattern_ascii_pointer_3([MarshalAs(UnmanagedType.LPStr)] string x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ascii_pointer_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr pattern_ascii_pointer_4([MarshalAs(UnmanagedType.LPStr)] string x, uint l);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ascii_pointer_5")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte pattern_ascii_pointer_5([MarshalAs(UnmanagedType.LPStr)] string x, uint i);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ascii_pointer_return_slice")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial SliceUseCStrPtr pattern_ascii_pointer_return_slice();


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Utf8String pattern_string_1(Utf8String x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint pattern_string_2(Utf8String x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Utf8String pattern_string_3();


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial UseString pattern_string_4(UseString x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_5")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultUseStringError pattern_string_5(UseString x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_6a")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError pattern_string_6a(ref UseString ignored);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_6b")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError pattern_string_6b(ref UseString y);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_7")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultUtf8StringError pattern_string_7(SliceUtf8String x, ulong i);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_8")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultUseStringError pattern_string_8(SliceUseString x, ulong i);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_9")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultUtf8StringError pattern_string_9();


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_10")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_string_10(Utf8String ignored);


        [LibraryImport(NativeLib, EntryPoint = "pattern_string_11")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_string_11(ref Utf8String ignored);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint pattern_ffi_slice_1(SliceU32 ffi_slice);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_1b")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint pattern_ffi_slice_1b(SliceMutU32 ffi_slice);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Vec3f32 pattern_ffi_slice_2(SliceVec3f32 ffi_slice, int i);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_ffi_slice_3(SliceMutU8 slice, CallbackSliceMut callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe void pattern_ffi_slice_3(SliceMutU8 slice, CallbackSliceMutDelegate callback)
        {
            var callback_wrapped = new CallbackSliceMut(callback);
            try
            {
                pattern_ffi_slice_3(slice, callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_ffi_slice_4(SliceU8 slice, SliceMutU8 slice2);


        /// It is (probably?) UB to call this function with the same FFI slice data at the same time.
        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_5")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_ffi_slice_5(ref SliceU8 slice, ref SliceMutU8 slice2);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_6")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_ffi_slice_6(ref SliceMutU8 slice, CallbackU8 callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe void pattern_ffi_slice_6(ref SliceMutU8 slice, CallbackU8Delegate callback)
        {
            var callback_wrapped = new CallbackU8(callback);
            try
            {
                pattern_ffi_slice_6(ref slice, callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_8")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_ffi_slice_8(ref SliceMutCharArray slice, CallbackCharArray2 callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe void pattern_ffi_slice_8(ref SliceMutCharArray slice, CallbackCharArray2Delegate callback)
        {
            var callback_wrapped = new CallbackCharArray2(callback);
            try
            {
                pattern_ffi_slice_8(ref slice, callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_9")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Utf8String pattern_ffi_slice_9(SliceUseString slice);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_delegate")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte pattern_ffi_slice_delegate(CallbackFFISlice callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe byte pattern_ffi_slice_delegate(CallbackFFISliceDelegate callback)
        {
            var callback_wrapped = new CallbackFFISlice(callback);
            try
            {
                return pattern_ffi_slice_delegate(callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_slice_delegate_huge")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Vec3f32 pattern_ffi_slice_delegate_huge(CallbackHugeVecSlice callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Vec3f32 pattern_ffi_slice_delegate_huge(CallbackHugeVecSliceDelegate callback)
        {
            var callback_wrapped = new CallbackHugeVecSlice(callback);
            try
            {
                return pattern_ffi_slice_delegate_huge(callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_option_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial OptionInner pattern_ffi_option_1(OptionInner x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_option_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Inner pattern_ffi_option_2(OptionInner x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_option_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial OptionOptionResultOptionUtf8StringError pattern_ffi_option_3(OptionOptionResultOptionUtf8StringError x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_bool")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial Bool pattern_ffi_bool(Bool ffi_bool);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_cchar")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial sbyte pattern_ffi_cchar(sbyte ffi_cchar);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_cchar_const_pointer")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr pattern_ffi_cchar_const_pointer(IntPtr ffi_cchar);


        [LibraryImport(NativeLib, EntryPoint = "pattern_ffi_cchar_mut_pointer")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr pattern_ffi_cchar_mut_pointer(IntPtr ffi_cchar);


        [LibraryImport(NativeLib, EntryPoint = "pattern_result_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultU32Error pattern_result_1(ResultU32Error x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_result_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError pattern_result_2();


        [LibraryImport(NativeLib, EntryPoint = "pattern_result_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError pattern_result_3(ResultError x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_result_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultVoid pattern_result_4(ResultVoid x);


        [LibraryImport(NativeLib, EntryPoint = "pattern_api_guard")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ulong pattern_api_guard();


        [LibraryImport(NativeLib, EntryPoint = "pattern_callback_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint pattern_callback_1(MyCallback callback, uint x);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe uint pattern_callback_1(MyCallbackDelegate callback, uint x)
        {
            var callback_wrapped = new MyCallback(callback);
            try
            {
                return pattern_callback_1(callback_wrapped, x);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_callback_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial MyCallbackVoid pattern_callback_2(MyCallbackVoid callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe MyCallbackVoid pattern_callback_2(MyCallbackVoidDelegate callback)
        {
            var callback_wrapped = new MyCallbackVoid(callback);
            try
            {
                return pattern_callback_2(callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_callback_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint pattern_callback_4(MyCallbackNamespaced callback, uint x);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe uint pattern_callback_4(MyCallbackNamespacedDelegate callback, uint x)
        {
            var callback_wrapped = new MyCallbackNamespaced(callback);
            try
            {
                return pattern_callback_4(callback_wrapped, x);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_callback_5")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial SumDelegate1 pattern_callback_5();


        [LibraryImport(NativeLib, EntryPoint = "pattern_callback_6")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial SumDelegate2 pattern_callback_6();


        [LibraryImport(NativeLib, EntryPoint = "pattern_callback_7")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError pattern_callback_7(SumDelegateReturn c1, SumDelegateReturn2 c2, int x, int i, ref int o);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe ResultError pattern_callback_7(SumDelegateReturnDelegate c1, SumDelegateReturn2Delegate c2, int x, int i, ref int o)
        {
            var c1_wrapped = new SumDelegateReturn(c1);
            var c2_wrapped = new SumDelegateReturn2(c2);
            try
            {
                return pattern_callback_7(c1_wrapped, c2_wrapped, x, i, ref o);
            }
            finally
            {
                c1_wrapped.Dispose();
                c2_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_callback_8")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_callback_8(StringCallback cb, NestedStringCallback cb2, Utf8String s);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe void pattern_callback_8(StringCallbackDelegate cb, NestedStringCallbackDelegate cb2, Utf8String s)
        {
            var cb_wrapped = new StringCallback(cb);
            var cb2_wrapped = new NestedStringCallback(cb2);
            try
            {
                pattern_callback_8(cb_wrapped, cb2_wrapped, s);
            }
            finally
            {
                cb_wrapped.Dispose();
                cb2_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "pattern_surrogates_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_surrogates_1(Local s, ref Container c);


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_1")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial VecU8 pattern_vec_1();


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_vec_2(VecU8 ignored);


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_3")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial VecU8 pattern_vec_3(VecU8 v);


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_4")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial VecU8 pattern_vec_4(ref VecU8 v);


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_5")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial VecUtf8String pattern_vec_5(VecUtf8String v);


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_6")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial VecVec3f32 pattern_vec_6(VecVec3f32 v);


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_7")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void pattern_vec_7(UseSliceAndVec ignored);


        [LibraryImport(NativeLib, EntryPoint = "pattern_vec_8")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial UseSliceAndVec pattern_vec_8(UseSliceAndVec v);


        [LibraryImport(NativeLib, EntryPoint = "wire_accept_string_2")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void wire_accept_string_2(WireOfMyString input);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_async_basic_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncBasicError service_async_basic_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_async_basic_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncBasicError service_async_basic_new();


        [LibraryImport(NativeLib, EntryPoint = "service_async_basic_call")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_basic_call(IntPtr _context, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task service_async_basic_call(IntPtr _context)
        {
            var (_cb, _cs) = _trampolineResultError.NewCall();
            try
            {
                service_async_basic_call(_context, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_async_sleep_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncSleepError service_async_sleep_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_async_sleep_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncSleepError service_async_sleep_new();


        [LibraryImport(NativeLib, EntryPoint = "service_async_sleep_return_after_ms")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_sleep_return_after_ms(IntPtr _context, ulong x, ulong ms, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task<ulong> service_async_sleep_return_after_ms(IntPtr _context, ulong x, ulong ms)
        {
            var (_cb, _cs) = _trampolineResultU64Error.NewCall();
            try
            {
                service_async_sleep_return_after_ms(_context, x, ms, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_async_vec_string_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncVecStringError service_async_vec_string_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_async_vec_string_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncVecStringError service_async_vec_string_new();


        [LibraryImport(NativeLib, EntryPoint = "service_async_vec_string_handle_string")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_vec_string_handle_string(IntPtr _context, Utf8String s, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task<Utf8String> service_async_vec_string_handle_string(IntPtr _context, Utf8String s)
        {
            var (_cb, _cs) = _trampolineResultUtf8StringError.NewCall();
            try
            {
                service_async_vec_string_handle_string(_context, s, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        [LibraryImport(NativeLib, EntryPoint = "service_async_vec_string_handle_vec_string")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_vec_string_handle_vec_string(IntPtr _context, VecUtf8String s, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task<VecUtf8String> service_async_vec_string_handle_vec_string(IntPtr _context, VecUtf8String s)
        {
            var (_cb, _cs) = _trampolineResultVecUtf8StringError.NewCall();
            try
            {
                service_async_vec_string_handle_vec_string(_context, s, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        [LibraryImport(NativeLib, EntryPoint = "service_async_vec_string_handle_nested_string")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_vec_string_handle_nested_string(IntPtr _context, Utf8String s, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task<UseString> service_async_vec_string_handle_nested_string(IntPtr _context, Utf8String s)
        {
            var (_cb, _cs) = _trampolineResultUseStringError.NewCall();
            try
            {
                service_async_vec_string_handle_nested_string(_context, s, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_async_result_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncResultError service_async_result_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_async_result_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncResultError service_async_result_new();


        [LibraryImport(NativeLib, EntryPoint = "service_async_result_success")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_result_success(IntPtr _context, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task service_async_result_success(IntPtr _context)
        {
            var (_cb, _cs) = _trampolineResultError.NewCall();
            try
            {
                service_async_result_success(_context, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        [LibraryImport(NativeLib, EntryPoint = "service_async_result_fail")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_result_fail(IntPtr _context, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task service_async_result_fail(IntPtr _context)
        {
            var (_cb, _cs) = _trampolineResultError.NewCall();
            try
            {
                service_async_result_fail(_context, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_async_structs_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncStructsError service_async_structs_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_async_structs_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceAsyncStructsError service_async_structs_new();


        [LibraryImport(NativeLib, EntryPoint = "service_async_structs_process_struct")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_async_structs_process_struct(IntPtr _context, NestedArray x, AsyncCallbackCommonNative _async_callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Task<NestedArray> service_async_structs_process_struct(IntPtr _context, NestedArray x)
        {
            var (_cb, _cs) = _trampolineResultNestedArrayError.NewCall();
            try
            {
                service_async_structs_process_struct(_context, x, _cb).AsOk();
                return _cs;
            }
            finally
            {
            }
            return _cs;
        }

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_basic_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceBasicError service_basic_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_basic_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceBasicError service_basic_new();


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_main_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceMainError service_main_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_main_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceMainError service_main_new(uint x);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_dependent_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceDependentError service_dependent_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_dependent_from_main")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceDependentError service_dependent_from_main(IntPtr main);


        [LibraryImport(NativeLib, EntryPoint = "service_dependent_get")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint service_dependent_get(IntPtr _context);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_result_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceResultError service_result_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_result_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceResultError service_result_new();


        [LibraryImport(NativeLib, EntryPoint = "service_result_test")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_result_test(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_result_result_u32")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultU32Error service_result_result_u32(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_result_result_string")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultUtf8StringError service_result_result_string(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_result_result_option_enum")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultOptionEnumPayloadError service_result_result_option_enum(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_result_result_slice")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultU32Error service_result_result_slice(IntPtr _context, SliceU32 slice, ulong i);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_on_panic_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceOnPanicError service_on_panic_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_on_panic_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceOnPanicError service_on_panic_new();


        /// Methods returning a Result<(), _> are the default and do not
        /// need annotations.
        [LibraryImport(NativeLib, EntryPoint = "service_on_panic_return_result")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_on_panic_return_result(IntPtr _context, uint anon1);


        /// Methods returning a value need an `on_panic` annotation.
        [LibraryImport(NativeLib, EntryPoint = "service_on_panic_return_default_value")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial uint service_on_panic_return_default_value(IntPtr _context, uint x);


        /// This function has no panic safeguards. It will be a bit faster to
        /// call, but if it panics your host app will abort.
        [LibraryImport(NativeLib, EntryPoint = "service_on_panic_return_ub_on_panic")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr service_on_panic_return_ub_on_panic(IntPtr _context);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_callbacks_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceCallbacksError service_callbacks_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_callbacks_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceCallbacksError service_callbacks_new();


        [LibraryImport(NativeLib, EntryPoint = "service_callbacks_callback_simple")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_callbacks_callback_simple(IntPtr _context, MyCallback callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe ResultError service_callbacks_callback_simple(IntPtr _context, MyCallbackDelegate callback)
        {
            var callback_wrapped = new MyCallback(callback);
            try
            {
                return service_callbacks_callback_simple(_context, callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "service_callbacks_callback_ffi_return")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_callbacks_callback_ffi_return(IntPtr _context, SumDelegateReturn callback);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe ResultError service_callbacks_callback_ffi_return(IntPtr _context, SumDelegateReturnDelegate callback)
        {
            var callback_wrapped = new SumDelegateReturn(callback);
            try
            {
                return service_callbacks_callback_ffi_return(_context, callback_wrapped);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "service_callbacks_callback_with_slice")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_callbacks_callback_with_slice(IntPtr _context, SumDelegateReturn callback, SliceI32 input);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe ResultError service_callbacks_callback_with_slice(IntPtr _context, SumDelegateReturnDelegate callback, SliceI32 input)
        {
            var callback_wrapped = new SumDelegateReturn(callback);
            try
            {
                return service_callbacks_callback_with_slice(_context, callback_wrapped, input);
            }
            finally
            {
                callback_wrapped.Dispose();
            }
        }

        [LibraryImport(NativeLib, EntryPoint = "service_callbacks_set_delegate_table")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void service_callbacks_set_delegate_table(IntPtr _context, CallbackTable table);


        [LibraryImport(NativeLib, EntryPoint = "service_callbacks_invoke_delegates")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_callbacks_invoke_delegates(IntPtr _context);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_ignoring_methods_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceIgnoringMethodsError service_ignoring_methods_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_ignoring_methods_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceIgnoringMethodsError service_ignoring_methods_new();


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_multiple_ctors_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceMultipleCtorsError service_multiple_ctors_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_multiple_ctors_new_with")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceMultipleCtorsError service_multiple_ctors_new_with(uint some_value);


        [LibraryImport(NativeLib, EntryPoint = "service_multiple_ctors_new_without")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceMultipleCtorsError service_multiple_ctors_new_without();


        [LibraryImport(NativeLib, EntryPoint = "service_multiple_ctors_new_with_string")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceMultipleCtorsError service_multiple_ctors_new_with_string([MarshalAs(UnmanagedType.LPStr)] string anon0);


        [LibraryImport(NativeLib, EntryPoint = "service_multiple_ctors_new_failing")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceMultipleCtorsError service_multiple_ctors_new_failing(byte some_value);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceVariousSlicesError service_various_slices_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceVariousSlicesError service_various_slices_new();


        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_mut_self")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte service_various_slices_mut_self(IntPtr _context, SliceU8 slice);


        /// Single line.
        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_mut_self_void")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void service_various_slices_mut_self_void(IntPtr _context, SliceBool slice);


        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_mut_self_ref")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte service_various_slices_mut_self_ref(IntPtr _context, ref byte x, ref byte y);


        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_mut_self_ref_slice")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte service_various_slices_mut_self_ref_slice(IntPtr _context, ref byte x, ref byte y, SliceU8 slice);


        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_mut_self_ref_slice_limited")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial byte service_various_slices_mut_self_ref_slice_limited(IntPtr _context, ref byte x, ref byte y, SliceU8 slice, SliceU8 slice2);


        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_mut_self_ffi_error")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_various_slices_mut_self_ffi_error(IntPtr _context, SliceMutU8 slice);


        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_mut_self_no_error")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultError service_various_slices_mut_self_no_error(IntPtr _context, SliceMutU8 slice);


        /// Warning, you _must_ discard the returned slice object before calling into this service
        /// again, as otherwise undefined behavior might happen.
        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_return_slice")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial SliceU32 service_various_slices_return_slice(IntPtr _context);


        /// Warning, you _must_ discard the returned slice object before calling into this service
        /// again, as otherwise undefined behavior might happen.
        [LibraryImport(NativeLib, EntryPoint = "service_various_slices_return_slice_mut")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial SliceMutU32 service_various_slices_return_slice_mut(IntPtr _context);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [LibraryImport(NativeLib, EntryPoint = "service_strings_destroy")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceStringsError service_strings_destroy(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_strings_new")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceStringsError service_strings_new();


        [LibraryImport(NativeLib, EntryPoint = "service_strings_new_string")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial ResultConstPtrServiceStringsError service_strings_new_string(Utf8String x);


        [LibraryImport(NativeLib, EntryPoint = "service_strings_pass_cstr")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void service_strings_pass_cstr(IntPtr _context, [MarshalAs(UnmanagedType.LPStr)] string anon1);


        [LibraryImport(NativeLib, EntryPoint = "service_strings_return_cstr")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial IntPtr service_strings_return_cstr(IntPtr _context);


        [LibraryImport(NativeLib, EntryPoint = "service_strings_callback_string")]
        [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void service_strings_callback_string(IntPtr _context, Utf8String s, StringCallback cb);

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe void service_strings_callback_string(IntPtr _context, Utf8String s, StringCallbackDelegate cb)
        {
            var cb_wrapped = new StringCallback(cb);
            try
            {
                service_strings_callback_string(_context, s, cb_wrapped);
            }
            finally
            {
                cb_wrapped.Dispose();
            }
        }

    }

    /// Documented enum.
    public partial struct EnumDocumented
    {
        uint _variant;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct EnumDocumented 
    {




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal EnumDocumented ToManaged()
            {
                var _managed = new EnumDocumented();
                _managed._variant = _variant;
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        public static EnumDocumented A => new() { _variant = 0 };
        public static EnumDocumented B => new() { _variant = 1 };
        public static EnumDocumented C => new() { _variant = 2 };

        public bool IsA => _variant == 0;
        public bool IsB => _variant == 1;
        public bool IsC => _variant == 2;

        public void AsA() { if (_variant != 0) throw ExceptionForVariant(); }
        public void AsB() { if (_variant != 1) throw ExceptionForVariant(); }
        public void AsC() { if (_variant != 2) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "A";
            if (_variant == 1) return "B";
            if (_variant == 2) return "C";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException();
            if (_variant == 1) return new EnumException();
            if (_variant == 2) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(EnumDocumented), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private EnumDocumented _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(EnumDocumented managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(EnumDocumented managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public EnumDocumented ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct EnumNum
    {
        uint _variant;
        nuint _A;
        nint _C;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct EnumNum 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedA
        {
            internal uint _variant;
            internal nuint _A;
        }


        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedC
        {
            internal uint _variant;
            internal nint _C;
        }


        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedA _A;

            [FieldOffset(0)]
            internal UnmanagedC _C;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal EnumNum ToManaged()
            {
                var _managed = new EnumNum();
                _managed._variant = _variant;
                if (_variant == 0) _managed._A = _A._A;
                if (_variant == 2) _managed._C = _C._C;
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._A._A = _A;
            if (_variant == 2) _unmanaged._C._C = _C;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._A._A = _A;
            if (_variant == 2) _unmanaged._C._C = _C;
            return _unmanaged;
        }

        public static EnumNum A(nuint value) => new() { _variant = 0, _A = value };
        public static EnumNum B => new() { _variant = 1 };
        public static EnumNum C(nint value) => new() { _variant = 2, _C = value };

        public bool IsA => _variant == 0;
        public bool IsB => _variant == 1;
        public bool IsC => _variant == 2;

        public nuint AsA() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _A; } }
        public void AsB() { if (_variant != 1) throw ExceptionForVariant(); }
        public nint AsC() { if (_variant != 2) { throw ExceptionForVariant(); } else { return _C; } }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "A(...)";
            if (_variant == 1) return "B";
            if (_variant == 2) return "C(...)";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<nuint>(_A);
            if (_variant == 1) return new EnumException();
            if (_variant == 2) return new EnumException<nint>(_C);
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(EnumNum), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private EnumNum _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(EnumNum managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(EnumNum managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public EnumNum ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct EnumPayload
    {
        uint _variant;
        Vec3f32 _B;
        uint _C;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct EnumPayload 
    {

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedB
        {
            internal uint _variant;
            internal Vec3f32.Unmanaged _B;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedC
        {
            internal uint _variant;
            internal uint _C;
        }


        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedB _B;

            [FieldOffset(0)]
            internal UnmanagedC _C;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal EnumPayload ToManaged()
            {
                var _managed = new EnumPayload();
                _managed._variant = _variant;
                if (_variant == 1) _managed._B = _B._B.ToManaged();
                if (_variant == 2) _managed._C = _C._C;
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 1) _unmanaged._B._B = _B.ToUnmanaged();
            if (_variant == 2) _unmanaged._C._C = _C;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 1) _unmanaged._B._B = _B.ToUnmanaged();
            if (_variant == 2) _unmanaged._C._C = _C;
            return _unmanaged;
        }

        public static EnumPayload A => new() { _variant = 0 };
        public static EnumPayload B(Vec3f32 value) => new() { _variant = 1, _B = value };
        public static EnumPayload C(uint value) => new() { _variant = 2, _C = value };

        public bool IsA => _variant == 0;
        public bool IsB => _variant == 1;
        public bool IsC => _variant == 2;

        public void AsA() { if (_variant != 0) throw ExceptionForVariant(); }
        public Vec3f32 AsB() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _B; } }
        public uint AsC() { if (_variant != 2) { throw ExceptionForVariant(); } else { return _C; } }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "A";
            if (_variant == 1) return "B(...)";
            if (_variant == 2) return "C(...)";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException();
            if (_variant == 1) return new EnumException<Vec3f32>(_B);
            if (_variant == 2) return new EnumException<uint>(_C);
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(EnumPayload), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private EnumPayload _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(EnumPayload managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(EnumPayload managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public EnumPayload ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct EnumRenamed
    {
        uint _variant;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct EnumRenamed 
    {


        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal EnumRenamed ToManaged()
            {
                var _managed = new EnumRenamed();
                _managed._variant = _variant;
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        public static EnumRenamed X => new() { _variant = 0 };

        public bool IsX => _variant == 0;

        public void AsX() { if (_variant != 0) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "X";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(EnumRenamed), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private EnumRenamed _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(EnumRenamed managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(EnumRenamed managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public EnumRenamed ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Error
    {
        uint _variant;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Error 
    {


        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal Error ToManaged()
            {
                var _managed = new Error();
                _managed._variant = _variant;
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        public static Error Fail => new() { _variant = 0 };

        public bool IsFail => _variant == 0;

        public void AsFail() { if (_variant != 0) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Fail";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(Error), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private Error _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Error managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Error managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Error ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial class Layer3
    {
        uint _variant;
        Layer1Utf8String _A;
        Layer2Utf8String _B;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class Layer3 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedA
        {
            internal uint _variant;
            internal Layer1Utf8String.Unmanaged _A;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedB
        {
            internal uint _variant;
            internal Layer2Utf8String.Unmanaged _B;
        }

        public void Dispose()
        {
            if (_variant == 0) { _A.Dispose(); }
            if (_variant == 1) { _B.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedA _A;

            [FieldOffset(0)]
            internal UnmanagedB _B;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal Layer3 IntoManaged()
            {
                var _managed = new Layer3();
                _managed._variant = _variant;
                if (_variant == 0) _managed._A = _A._A.IntoManaged();
                if (_variant == 1) _managed._B = _B._B.IntoManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._A._A = _A.IntoUnmanaged();
            if (_variant == 1) _unmanaged._B._B = _B.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._A._A = _A.AsUnmanaged();
            if (_variant == 1) _unmanaged._B._B = _B.AsUnmanaged();
            return _unmanaged;
        }

        public static Layer3 A(Layer1Utf8String value) => new() { _variant = 0, _A = value };
        public static Layer3 B(Layer2Utf8String value) => new() { _variant = 1, _B = value };

        public bool IsA => _variant == 0;
        public bool IsB => _variant == 1;

        public Layer1Utf8String AsA() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _A; } }
        public Layer2Utf8String AsB() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _B; } }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "A(...)";
            if (_variant == 1) return "B(...)";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<Layer1Utf8String>(_A);
            if (_variant == 1) return new EnumException<Layer2Utf8String>(_B);
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(Layer3), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private Layer3 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Layer3 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Layer3 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Layer3 ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Array
    {
        public byte[] data;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Array 
    {
        public Array() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            {
                if (data == null) { throw new InvalidOperationException("Array 'data' must not be null"); }
                if (data.Length != 16) { throw new InvalidOperationException("Array size mismatch for 'data'"); }
                var src = new ReadOnlySpan<byte>(data, 0, 16);
                var dst = new Span<byte>(_unmanaged.data, 16);
                src.CopyTo(dst);
            }
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            {
                if (data == null) { throw new InvalidOperationException("Array 'data' must not be null"); }
                if (data.Length != 16) { throw new InvalidOperationException("Array size mismatch for 'data'"); }
                var src = new ReadOnlySpan<byte>(data, 0, 16);
                var dst = new Span<byte>(_unmanaged.data, 16);
                src.CopyTo(dst);
            }
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public fixed byte data[16];

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Array ToManaged()
            {
                var _managed = new Array();
                fixed(byte* _fixed = data)
                {
                    _managed.data = new byte[16];
                    var src = new ReadOnlySpan<byte>(_fixed, 16);
                    var dst = new Span<byte>(_managed.data, 0, 16);
                    src.CopyTo(dst);
                }
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Array { ... }";
        }

        [CustomMarshaller(typeof(Array), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Array _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Array managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Array managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Array ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct BoolField
    {
        public bool val;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct BoolField 
    {
        public BoolField() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.val = (byte) (val ? 1 : 0);
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.val = (byte) (val ? 1 : 0);
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public byte val;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe BoolField ToManaged()
            {
                var _managed = new BoolField();
                _managed.val = val == 1;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "BoolField { ... }";
        }

        [CustomMarshaller(typeof(BoolField), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private BoolField _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(BoolField managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(BoolField managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public BoolField ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct CallbackTable
    {
        public MyCallback my_callback;
        public MyCallbackNamespaced my_callback_namespaced;
        public MyCallbackVoid my_callback_void;
        public MyCallbackContextual my_callback_contextual;
        public SumDelegate1 sum_delegate_1;
        public SumDelegate2 sum_delegate_2;
        public SumDelegateReturn sum_delegate_return;
        public SumDelegateReturn2 sum_delegate_return_2;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct CallbackTable : IDisposable
    {
        public CallbackTable() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.my_callback = my_callback?.ToUnmanaged() ?? default;
            _unmanaged.my_callback_namespaced = my_callback_namespaced?.ToUnmanaged() ?? default;
            _unmanaged.my_callback_void = my_callback_void?.ToUnmanaged() ?? default;
            _unmanaged.my_callback_contextual = my_callback_contextual?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_1 = sum_delegate_1?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_2 = sum_delegate_2?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_return = sum_delegate_return?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_return_2 = sum_delegate_return_2?.ToUnmanaged() ?? default;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.my_callback = my_callback?.ToUnmanaged() ?? default;
            _unmanaged.my_callback_namespaced = my_callback_namespaced?.ToUnmanaged() ?? default;
            _unmanaged.my_callback_void = my_callback_void?.ToUnmanaged() ?? default;
            _unmanaged.my_callback_contextual = my_callback_contextual?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_1 = sum_delegate_1?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_2 = sum_delegate_2?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_return = sum_delegate_return?.ToUnmanaged() ?? default;
            _unmanaged.sum_delegate_return_2 = sum_delegate_return_2?.ToUnmanaged() ?? default;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public MyCallback.Unmanaged my_callback;
            public MyCallbackNamespaced.Unmanaged my_callback_namespaced;
            public MyCallbackVoid.Unmanaged my_callback_void;
            public MyCallbackContextual.Unmanaged my_callback_contextual;
            public SumDelegate1.Unmanaged sum_delegate_1;
            public SumDelegate2.Unmanaged sum_delegate_2;
            public SumDelegateReturn.Unmanaged sum_delegate_return;
            public SumDelegateReturn2.Unmanaged sum_delegate_return_2;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe CallbackTable ToManaged()
            {
                var _managed = new CallbackTable();
                _managed.my_callback = my_callback.ToManaged();
                _managed.my_callback_namespaced = my_callback_namespaced.ToManaged();
                _managed.my_callback_void = my_callback_void.ToManaged();
                _managed.my_callback_contextual = my_callback_contextual.ToManaged();
                _managed.sum_delegate_1 = sum_delegate_1.ToManaged();
                _managed.sum_delegate_2 = sum_delegate_2.ToManaged();
                _managed.sum_delegate_return = sum_delegate_return.ToManaged();
                _managed.sum_delegate_return_2 = sum_delegate_return_2.ToManaged();
                return _managed;
            }
        }

        public void Dispose()
        {
            my_callback.Dispose();
            my_callback_namespaced.Dispose();
            my_callback_void.Dispose();
            my_callback_contextual.Dispose();
            sum_delegate_1.Dispose();
            sum_delegate_2.Dispose();
            sum_delegate_return.Dispose();
            sum_delegate_return_2.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "CallbackTable { ... }";
        }

        [CustomMarshaller(typeof(CallbackTable), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private CallbackTable _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CallbackTable managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CallbackTable managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CallbackTable ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct CharArray
    {
        public FixedString str;
        public FixedString str_2;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct CharArray 
    {
        public CharArray() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.str = str.ToUnmanaged();
            _unmanaged.str_2 = str_2.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.str = str.ToUnmanaged();
            _unmanaged.str_2 = str_2.ToUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public FixedString.Unmanaged str;
            public FixedString.Unmanaged str_2;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe CharArray ToManaged()
            {
                var _managed = new CharArray();
                _managed.str = str.ToManaged();
                _managed.str_2 = str_2.ToManaged();
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "CharArray { ... }";
        }

        [CustomMarshaller(typeof(CharArray), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private CharArray _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CharArray managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CharArray managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CharArray ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Container
    {
        public Local foreign;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Container 
    {
        public Container() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.foreign = foreign.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.foreign = foreign.ToUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public Local.Unmanaged foreign;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Container ToManaged()
            {
                var _managed = new Container();
                _managed.foreign = foreign.ToManaged();
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Container { ... }";
        }

        [CustomMarshaller(typeof(Container), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Container _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Container managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Container managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Container ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct ExtraTypef32
    {
        public float x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ExtraTypef32 
    {
        public ExtraTypef32() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public float x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe ExtraTypef32 ToManaged()
            {
                var _managed = new ExtraTypef32();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "ExtraTypef32 { ... }";
        }

        [CustomMarshaller(typeof(ExtraTypef32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private ExtraTypef32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ExtraTypef32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ExtraTypef32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ExtraTypef32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct FixedString
    {
        public byte[] data;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct FixedString 
    {
        public FixedString() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            {
                if (data == null) { throw new InvalidOperationException("Array 'data' must not be null"); }
                if (data.Length != 32) { throw new InvalidOperationException("Array size mismatch for 'data'"); }
                var src = new ReadOnlySpan<byte>(data, 0, 32);
                var dst = new Span<byte>(_unmanaged.data, 32);
                src.CopyTo(dst);
            }
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            {
                if (data == null) { throw new InvalidOperationException("Array 'data' must not be null"); }
                if (data.Length != 32) { throw new InvalidOperationException("Array size mismatch for 'data'"); }
                var src = new ReadOnlySpan<byte>(data, 0, 32);
                var dst = new Span<byte>(_unmanaged.data, 32);
                src.CopyTo(dst);
            }
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public fixed byte data[32];

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe FixedString ToManaged()
            {
                var _managed = new FixedString();
                fixed(byte* _fixed = data)
                {
                    _managed.data = new byte[32];
                    var src = new ReadOnlySpan<byte>(_fixed, 32);
                    var dst = new Span<byte>(_managed.data, 0, 32);
                    src.CopyTo(dst);
                }
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "FixedString { ... }";
        }

        [CustomMarshaller(typeof(FixedString), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private FixedString _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(FixedString managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(FixedString managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public FixedString ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Genericu32
    {
        public IntPtr x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Genericu32 
    {
        public Genericu32() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Genericu32 ToManaged()
            {
                var _managed = new Genericu32();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Genericu32 { ... }";
        }

        [CustomMarshaller(typeof(Genericu32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Genericu32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Genericu32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Genericu32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Genericu32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Genericu8
    {
        public IntPtr x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Genericu8 
    {
        public Genericu8() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Genericu8 ToManaged()
            {
                var _managed = new Genericu8();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Genericu8 { ... }";
        }

        [CustomMarshaller(typeof(Genericu8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Genericu8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Genericu8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Genericu8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Genericu8 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct IVec3
    {
        public nint x;
        public nint y;
        public nint z;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct IVec3 
    {
        public IVec3() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            _unmanaged.z = z;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            _unmanaged.z = z;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public nint x;
            public nint y;
            public nint z;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe IVec3 ToManaged()
            {
                var _managed = new IVec3();
                _managed.x = x;
                _managed.y = y;
                _managed.z = z;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "IVec3 { ... }";
        }

        [CustomMarshaller(typeof(IVec3), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private IVec3 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(IVec3 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(IVec3 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public IVec3 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Inner
    {
        public float x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Inner 
    {
        public Inner() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public float x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Inner ToManaged()
            {
                var _managed = new Inner();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Inner { ... }";
        }

        [CustomMarshaller(typeof(Inner), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Inner _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Inner managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Inner managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Inner ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial class Layer1Utf8String
    {
        public OptionUtf8String maybe_1;
        public VecUtf8String maybe_2;
        public Utf8String maybe_3;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class Layer1Utf8String : IDisposable
    {
        public Layer1Utf8String() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.maybe_1 = maybe_1.IntoUnmanaged();
            _unmanaged.maybe_2 = maybe_2.IntoUnmanaged();
            _unmanaged.maybe_3 = maybe_3.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.maybe_1 = maybe_1.AsUnmanaged();
            _unmanaged.maybe_2 = maybe_2.AsUnmanaged();
            _unmanaged.maybe_3 = maybe_3.AsUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public OptionUtf8String.Unmanaged maybe_1;
            public VecUtf8String.Unmanaged maybe_2;
            public Utf8String.Unmanaged maybe_3;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Layer1Utf8String IntoManaged()
            {
                var _managed = new Layer1Utf8String();
                _managed.maybe_1 = maybe_1.IntoManaged();
                _managed.maybe_2 = maybe_2.IntoManaged();
                _managed.maybe_3 = maybe_3.IntoManaged();
                return _managed;
            }
        }

        public void Dispose()
        {
            maybe_1.Dispose();
            maybe_2.Dispose();
            maybe_3.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Layer1Utf8String { ... }";
        }

        [CustomMarshaller(typeof(Layer1Utf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Layer1Utf8String _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Layer1Utf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Layer1Utf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Layer1Utf8String ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial class Layer2Utf8String
    {
        public Layer1Utf8String layer_1;
        public Vec3f32 vec;
        public EnumPayload the_enum;
        public VecUtf8String strings;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class Layer2Utf8String : IDisposable
    {
        public Layer2Utf8String() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.layer_1 = layer_1.IntoUnmanaged();
            _unmanaged.vec = vec.ToUnmanaged();
            _unmanaged.the_enum = the_enum.ToUnmanaged();
            _unmanaged.strings = strings.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.layer_1 = layer_1.AsUnmanaged();
            _unmanaged.vec = vec.ToUnmanaged();
            _unmanaged.the_enum = the_enum.ToUnmanaged();
            _unmanaged.strings = strings.AsUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public Layer1Utf8String.Unmanaged layer_1;
            public Vec3f32.Unmanaged vec;
            public EnumPayload.Unmanaged the_enum;
            public VecUtf8String.Unmanaged strings;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Layer2Utf8String IntoManaged()
            {
                var _managed = new Layer2Utf8String();
                _managed.layer_1 = layer_1.IntoManaged();
                _managed.vec = vec.ToManaged();
                _managed.the_enum = the_enum.ToManaged();
                _managed.strings = strings.IntoManaged();
                return _managed;
            }
        }

        public void Dispose()
        {
            layer_1.Dispose();
            strings.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Layer2Utf8String { ... }";
        }

        [CustomMarshaller(typeof(Layer2Utf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Layer2Utf8String _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Layer2Utf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Layer2Utf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Layer2Utf8String ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Local
    {
        uint x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Local 
    {
        public Local() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public uint x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Local ToManaged()
            {
                var _managed = new Local();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Local { ... }";
        }

        [CustomMarshaller(typeof(Local), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Local _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Local managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Local managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Local ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct NestedArray
    {
        public EnumRenamed field_enum;
        public Vec3f32 field_vec;
        public bool field_bool;
        public int field_int;
        public ushort[] field_array;
        public ushort[] field_array_2;
        public Array field_struct;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct NestedArray 
    {
        public NestedArray() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.field_enum = field_enum.ToUnmanaged();
            _unmanaged.field_vec = field_vec.ToUnmanaged();
            _unmanaged.field_bool = (byte) (field_bool ? 1 : 0);
            _unmanaged.field_int = field_int;
            {
                if (field_array == null) { throw new InvalidOperationException("Array 'field_array' must not be null"); }
                if (field_array.Length != 5) { throw new InvalidOperationException("Array size mismatch for 'field_array'"); }
                var src = new ReadOnlySpan<ushort>(field_array, 0, 5);
                var dst = new Span<ushort>(_unmanaged.field_array, 5);
                src.CopyTo(dst);
            }
            {
                if (field_array_2 == null) { throw new InvalidOperationException("Array 'field_array_2' must not be null"); }
                if (field_array_2.Length != 5) { throw new InvalidOperationException("Array size mismatch for 'field_array_2'"); }
                var src = new ReadOnlySpan<ushort>(field_array_2, 0, 5);
                var dst = new Span<ushort>(_unmanaged.field_array_2, 5);
                src.CopyTo(dst);
            }
            _unmanaged.field_struct = field_struct.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.field_enum = field_enum.ToUnmanaged();
            _unmanaged.field_vec = field_vec.ToUnmanaged();
            _unmanaged.field_bool = (byte) (field_bool ? 1 : 0);
            _unmanaged.field_int = field_int;
            {
                if (field_array == null) { throw new InvalidOperationException("Array 'field_array' must not be null"); }
                if (field_array.Length != 5) { throw new InvalidOperationException("Array size mismatch for 'field_array'"); }
                var src = new ReadOnlySpan<ushort>(field_array, 0, 5);
                var dst = new Span<ushort>(_unmanaged.field_array, 5);
                src.CopyTo(dst);
            }
            {
                if (field_array_2 == null) { throw new InvalidOperationException("Array 'field_array_2' must not be null"); }
                if (field_array_2.Length != 5) { throw new InvalidOperationException("Array size mismatch for 'field_array_2'"); }
                var src = new ReadOnlySpan<ushort>(field_array_2, 0, 5);
                var dst = new Span<ushort>(_unmanaged.field_array_2, 5);
                src.CopyTo(dst);
            }
            _unmanaged.field_struct = field_struct.ToUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public EnumRenamed.Unmanaged field_enum;
            public Vec3f32.Unmanaged field_vec;
            public byte field_bool;
            public int field_int;
            public fixed ushort field_array[5];
            public fixed ushort field_array_2[5];
            public Array.Unmanaged field_struct;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe NestedArray ToManaged()
            {
                var _managed = new NestedArray();
                _managed.field_enum = field_enum.ToManaged();
                _managed.field_vec = field_vec.ToManaged();
                _managed.field_bool = field_bool == 1;
                _managed.field_int = field_int;
                fixed(ushort* _fixed = field_array)
                {
                    _managed.field_array = new ushort[5];
                    var src = new ReadOnlySpan<ushort>(_fixed, 5);
                    var dst = new Span<ushort>(_managed.field_array, 0, 5);
                    src.CopyTo(dst);
                }
                fixed(ushort* _fixed = field_array_2)
                {
                    _managed.field_array_2 = new ushort[5];
                    var src = new ReadOnlySpan<ushort>(_fixed, 5);
                    var dst = new Span<ushort>(_managed.field_array_2, 0, 5);
                    src.CopyTo(dst);
                }
                _managed.field_struct = field_struct.ToManaged();
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "NestedArray { ... }";
        }

        [CustomMarshaller(typeof(NestedArray), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private NestedArray _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(NestedArray managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(NestedArray managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public NestedArray ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Packed1
    {
        public byte x;
        public ushort y;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Packed1 
    {
        public Packed1() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public unsafe struct Unmanaged
        {
            public byte x;
            public ushort y;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Packed1 ToManaged()
            {
                var _managed = new Packed1();
                _managed.x = x;
                _managed.y = y;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Packed1 { ... }";
        }

        [CustomMarshaller(typeof(Packed1), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Packed1 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Packed1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Packed1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Packed1 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Packed2
    {
        public ushort y;
        public byte x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Packed2 
    {
        public Packed2() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.y = y;
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.y = y;
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public unsafe struct Unmanaged
        {
            public ushort y;
            public byte x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Packed2 ToManaged()
            {
                var _managed = new Packed2();
                _managed.y = y;
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Packed2 { ... }";
        }

        [CustomMarshaller(typeof(Packed2), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Packed2 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Packed2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Packed2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Packed2 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Phantomu8
    {
        public uint x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Phantomu8 
    {
        public Phantomu8() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public uint x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Phantomu8 ToManaged()
            {
                var _managed = new Phantomu8();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Phantomu8 { ... }";
        }

        [CustomMarshaller(typeof(Phantomu8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Phantomu8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Phantomu8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Phantomu8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Phantomu8 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    /// Documented struct.
    public partial struct StructDocumented
    {
        /// Documented field.
        public float x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct StructDocumented 
    {
        public StructDocumented() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public float x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe StructDocumented ToManaged()
            {
                var _managed = new StructDocumented();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "StructDocumented { ... }";
        }

        [CustomMarshaller(typeof(StructDocumented), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private StructDocumented _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(StructDocumented managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(StructDocumented managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public StructDocumented ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct StructRenamed
    {
        public EnumRenamed e;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct StructRenamed 
    {
        public StructRenamed() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.e = e.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.e = e.ToUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public EnumRenamed.Unmanaged e;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe StructRenamed ToManaged()
            {
                var _managed = new StructRenamed();
                _managed.e = e.ToManaged();
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "StructRenamed { ... }";
        }

        [CustomMarshaller(typeof(StructRenamed), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private StructRenamed _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(StructRenamed managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(StructRenamed managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public StructRenamed ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Tupled
    {
        public byte x0;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Tupled 
    {
        public Tupled() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x0 = x0;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x0 = x0;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public byte x0;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Tupled ToManaged()
            {
                var _managed = new Tupled();
                _managed.x0 = x0;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Tupled { ... }";
        }

        [CustomMarshaller(typeof(Tupled), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Tupled _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Tupled managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Tupled managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Tupled ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct UseCStrPtr
    {
        public string ascii_string;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct UseCStrPtr 
    {
        public UseCStrPtr() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.ascii_string = IntPtr.Zero;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.ascii_string = IntPtr.Zero;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr ascii_string;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe UseCStrPtr ToManaged()
            {
                var _managed = new UseCStrPtr();
                _managed.ascii_string = string.Empty;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "UseCStrPtr { ... }";
        }

        [CustomMarshaller(typeof(UseCStrPtr), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private UseCStrPtr _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(UseCStrPtr managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(UseCStrPtr managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public UseCStrPtr ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial class UseSliceAndVec
    {
        public SliceUtf8String s1;
        public VecUtf8String s2;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class UseSliceAndVec : IDisposable
    {
        public UseSliceAndVec() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.s1 = s1.ToUnmanaged();
            _unmanaged.s2 = s2.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.s1 = s1.ToUnmanaged();
            _unmanaged.s2 = s2.AsUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public SliceUtf8String.Unmanaged s1;
            public VecUtf8String.Unmanaged s2;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe UseSliceAndVec IntoManaged()
            {
                var _managed = new UseSliceAndVec();
                _managed.s1 = s1.ToManaged();
                _managed.s2 = s2.IntoManaged();
                return _managed;
            }
        }

        public void Dispose()
        {
            s1.Dispose();
            s2.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "UseSliceAndVec { ... }";
        }

        [CustomMarshaller(typeof(UseSliceAndVec), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private UseSliceAndVec _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(UseSliceAndVec managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(UseSliceAndVec managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public UseSliceAndVec ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial class UseString
    {
        public Utf8String s1;
        public Utf8String s2;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class UseString : IDisposable
    {
        public UseString() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.s1 = s1.IntoUnmanaged();
            _unmanaged.s2 = s2.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.s1 = s1.AsUnmanaged();
            _unmanaged.s2 = s2.AsUnmanaged();
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public Utf8String.Unmanaged s1;
            public Utf8String.Unmanaged s2;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe UseString IntoManaged()
            {
                var _managed = new UseString();
                _managed.s1 = s1.IntoManaged();
                _managed.s2 = s2.IntoManaged();
                return _managed;
            }
        }

        public void Dispose()
        {
            s1.Dispose();
            s2.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "UseString { ... }";
        }

        [CustomMarshaller(typeof(UseString), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private UseString _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(UseString managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(UseString managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public UseString ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Vec1
    {
        public float x;
        public float y;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Vec1 
    {
        public Vec1() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public float x;
            public float y;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Vec1 ToManaged()
            {
                var _managed = new Vec1();
                _managed.x = x;
                _managed.y = y;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Vec1 { ... }";
        }

        [CustomMarshaller(typeof(Vec1), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Vec1 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Vec1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Vec1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Vec1 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Vec2
    {
        public double x;
        public double z;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Vec2 
    {
        public Vec2() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.z = z;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.z = z;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public double x;
            public double z;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Vec2 ToManaged()
            {
                var _managed = new Vec2();
                _managed.x = x;
                _managed.z = z;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Vec2 { ... }";
        }

        [CustomMarshaller(typeof(Vec2), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Vec2 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Vec2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Vec2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Vec2 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Vec3f32
    {
        public float x;
        public float y;
        public float z;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Vec3f32 
    {
        public Vec3f32() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            _unmanaged.z = z;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            _unmanaged.y = y;
            _unmanaged.z = z;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public float x;
            public float y;
            public float z;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Vec3f32 ToManaged()
            {
                var _managed = new Vec3f32();
                _managed.x = x;
                _managed.y = y;
                _managed.z = z;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Vec3f32 { ... }";
        }

        [CustomMarshaller(typeof(Vec3f32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Vec3f32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Vec3f32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Vec3f32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Vec3f32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Visibility1
    {
        public byte pblc;
        byte prvt;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Visibility1 
    {
        public Visibility1() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.pblc = pblc;
            _unmanaged.prvt = prvt;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.pblc = pblc;
            _unmanaged.prvt = prvt;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public byte pblc;
            public byte prvt;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Visibility1 ToManaged()
            {
                var _managed = new Visibility1();
                _managed.pblc = pblc;
                _managed.prvt = prvt;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Visibility1 { ... }";
        }

        [CustomMarshaller(typeof(Visibility1), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Visibility1 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Visibility1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Visibility1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Visibility1 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Visibility2
    {
        public byte pblc1;
        public byte pblc2;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Visibility2 
    {
        public Visibility2() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.pblc1 = pblc1;
            _unmanaged.pblc2 = pblc2;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.pblc1 = pblc1;
            _unmanaged.pblc2 = pblc2;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public byte pblc1;
            public byte pblc2;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Visibility2 ToManaged()
            {
                var _managed = new Visibility2();
                _managed.pblc1 = pblc1;
                _managed.pblc2 = pblc2;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Visibility2 { ... }";
        }

        [CustomMarshaller(typeof(Visibility2), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Visibility2 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Visibility2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Visibility2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Visibility2 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Weird1u32
    {
        uint x;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Weird1u32 
    {
        public Weird1u32() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.x = x;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public uint x;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Weird1u32 ToManaged()
            {
                var _managed = new Weird1u32();
                _managed.x = x;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Weird1u32 { ... }";
        }

        [CustomMarshaller(typeof(Weird1u32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Weird1u32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Weird1u32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Weird1u32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Weird1u32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public partial struct Weird2u8
    {
        byte t;
        byte[] a;
        IntPtr r;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Weird2u8 
    {
        public Weird2u8() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.t = t;
            {
                if (a == null) { throw new InvalidOperationException("Array 'a' must not be null"); }
                if (a.Length != 5) { throw new InvalidOperationException("Array size mismatch for 'a'"); }
                var src = new ReadOnlySpan<byte>(a, 0, 5);
                var dst = new Span<byte>(_unmanaged.a, 5);
                src.CopyTo(dst);
            }
            _unmanaged.r = r;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.t = t;
            {
                if (a == null) { throw new InvalidOperationException("Array 'a' must not be null"); }
                if (a.Length != 5) { throw new InvalidOperationException("Array size mismatch for 'a'"); }
                var src = new ReadOnlySpan<byte>(a, 0, 5);
                var dst = new Span<byte>(_unmanaged.a, 5);
                src.CopyTo(dst);
            }
            _unmanaged.r = r;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public byte t;
            public fixed byte a[5];
            public IntPtr r;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe Weird2u8 ToManaged()
            {
                var _managed = new Weird2u8();
                _managed.t = t;
                fixed(byte* _fixed = a)
                {
                    _managed.a = new byte[5];
                    var src = new ReadOnlySpan<byte>(_fixed, 5);
                    var dst = new Span<byte>(_managed.a, 0, 5);
                    src.CopyTo(dst);
                }
                _managed.r = r;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "Weird2u8 { ... }";
        }

        [CustomMarshaller(typeof(Weird2u8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private Weird2u8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Weird2u8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Weird2u8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Weird2u8 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///FFI buffer for Wire data transfer
    public partial struct WireBuffer
    {
        public IntPtr data;
        public int len;
        public int capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct WireBuffer 
    {
        public WireBuffer() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.data = data;
            _unmanaged.len = len;
            _unmanaged.capacity = capacity;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal unsafe Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged.data = data;
            _unmanaged.len = len;
            _unmanaged.capacity = capacity;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr data;
            public int len;
            public int capacity;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe WireBuffer ToManaged()
            {
                var _managed = new WireBuffer();
                _managed.data = data;
                _managed.len = len;
                _managed.capacity = capacity;
                return _managed;
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "WireBuffer { ... }";
        }

        [CustomMarshaller(typeof(WireBuffer), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }
        public ref struct Marshaller
        {
            private WireBuffer _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(WireBuffer managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(WireBuffer managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public WireBuffer ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }


    public partial class MyString
    {
        /// 
        public String x;
    }

    public partial class MyString
    {
        /// <summary>Empty constructor</summary>
        public MyString() { }

        /// <summary>Member-wise initializing constructor</summary>
        public MyString(String x)
        {
            this.x = x;
        }

        public override string ToString()
        {
            return "MyString { x = " + x + " }";
        }

        /// <summary>
        /// Deserialize the wire data back to a managed MyString object
        /// </summary>
        public static MyString Deserialize(BinaryReader reader)
        {
            return new MyString {
                x = WireInterop.DeserializeString(reader), /* string */
            };

        }

        /// <summary>
        /// Serialize a MyString object into this wire's buffer
        /// </summary>
        public void Serialize(BinaryWriter writer)
        {

            this.x.Serialize(writer); /* string */

        }

        /// <summary>
        /// Calculate the size needed to serialize a MyString object
        /// </summary>
        public int CalculateSize()
        {

            return 0
                + 
            Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(this.x ?? "") /* string */

            ;

        }
    }

    /// <summary>
    /// Extension methods for MyString to Serialize/Deserialize instances
    /// </summary>
    public static class SerdeMyStringExtensions
    {
        public static void SerializeMyString(BinaryWriter writer, MyString item)
        {
            item.Serialize(writer); 
        }

        public static MyString DeserializeMyString(BinaryReader reader)
        {
            return MyString.Deserialize(reader); 
        }

        public static int CalculateSize(MyString value)
        {
            return value.CalculateSize(); 
        }
    }

    /// <summary>
    /// FFI-safe wire representation for MyString.
    /// Mirrors the Rust Wire&lt;MyString&gt; structure layout.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct WireOfMyString
    {
        /// <summary>Pointer to buffer data</summary>
        byte* Data;

        /// <summary>Length of valid data in buffer</summary>
        int Length;

        /// <summary>
        /// Encoded capacity: 0=borrowed, >0=Rust-allocated, <0=C#-allocated (abs value = actual capacity)
        /// </summary>
        int Capacity;
    }

    /// <summary>
    /// FFI-safe wire representation for MyString.
    /// Mirrors the Rust Wire&lt;MyString&gt; structure layout.
    /// </summary>
    public unsafe partial struct WireOfMyString
    {
        /// <summary>
        /// Create a Wire from a managed MyString object with owned buffer
        /// </summary>
        public static WireOfMyString From(MyString value)
        {
            var size = value.CalculateSize();
            var buffer = Marshal.AllocHGlobal(size);
            var wire = new WireOfMyString
            {
                Data = (byte*)buffer,
                Length = (int)size,
                Capacity = -(int)size
            };

            try
            {
                value.Serialize(wire.Writer());
                return wire;
            }
            catch
            {
                Marshal.FreeHGlobal(buffer);
                throw;
            }
        }

        /// <summary>
        /// Create a Wire from a managed MyString object using provided buffer
        /// </summary>
        public static WireOfMyString From(MyString value, byte* buffer, int bufferSize)
        {
            var size = value.CalculateSize();
            if (size > bufferSize)
                throw new ArgumentException($"Buffer size {bufferSize} is too small for data size {size} when serializing MyString");

            var wire = new WireOfMyString
            {
                Data = buffer,
                Length = (int)size,
                Capacity = 0 // Indicates borrowed buffer
            };

            value.Serialize(wire.Writer());
            return wire;
        }

        public BinaryReader Reader()
        {
            // UIntPtr Ptr = (UIntPtr)Data;
            // throw new ArgumentException($"Creating a reader for wire with {Length} bytes in it, {Ptr} ptr and {Capacity} capacity");
            var reader = new BinaryReader(new UnmanagedMemoryStream(Data, Length));
            return reader;
        }

        public BinaryWriter Writer()
        {
            var writer = new BinaryWriter(new UnmanagedMemoryStream(Data, Length, Length, FileAccess.Write));
            return writer;
        }

        /// <summary>
        /// Free the buffer if this wire owns it
        /// </summary>
        public void Dispose()
        {
            if (Data != null)
            {
                if (IsOwned) {
                    if (Capacity > 0) {
                        WireInterop.interoptopus_wire_destroy((IntPtr)Data, Length, Capacity);
                    } else {
                        Marshal.FreeHGlobal((IntPtr)Data);
                    }
                }
                Data = null;
                Length = 0;
                Capacity = 0;
            }
        }

        /// <summary>
        /// Check if this wire owns its buffer
        /// </summary>
        public bool IsOwned => Capacity != 0;

        /// <summary>
        /// Check if the wire buffer is empty
        /// </summary>
        public bool IsEmpty => Length == 0;
    }

    /// <summary>
    /// Extension methods for MyString to create Wire instances
    /// </summary>
    public static class WireOfMyStringExtensions
    {
        /// <summary>
        /// Create a Wire with owned buffer from this MyString instance
        /// </summary>
        public static WireOfMyString Wire(this MyString value)
        {
            return WireOfMyString.From(value);
        }

        /// <summary>
        /// Create a Wire with borrowed buffer from this MyString instance
        /// </summary>
        public static unsafe WireOfMyString WireWithBuffer(this MyString value, byte* buffer, int bufferSize)
        {
            return WireOfMyString.From(value, buffer, bufferSize);
        }

        /// <summary>
        /// Calculate the wire size needed for this MyString instance
        /// </summary>
        public static int WireSize(this MyString value)
        {
            return value.CalculateSize();
        }

        /// <summary>
        /// Unwire a WireOfMyString back to a managed MyString object
        /// </summary>
        public static MyString Unwire(this WireOfMyString wire)
        {
            return MyString.Deserialize(wire.Reader());
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate byte InteropDelegate_fn_u8_rval_u8(byte x0);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void InteropDelegate_fn_CharArray_rval_void(CharArray x0);
    public delegate void InteropDelegate_fn_CharArray_rval_void_native(CharArray.Unmanaged x0);

    public partial class SliceBool
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceBool : IEnumerable<Bool>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<Bool> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe Bool this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<Bool>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<Bool>()));
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceBool() { }

        public static SliceBool From(IntPtr data, ulong len)
        {
            var rval = new SliceBool();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceBool From(Bool[] managed)
        {
            var rval = new SliceBool();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<Bool> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceBool), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceBool ToManaged()
            {
                return SliceBool.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceBool _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceBool managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceBool managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceBool ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceBoolExtensions
        {
            public static SliceBool Slice(this Bool[] s) { return SliceBool.From(s); }
        }


    public partial class SliceI32
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceI32 : IEnumerable<int>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<int> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe int this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<int>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<int>()));
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceI32() { }

        public static SliceI32 From(IntPtr data, ulong len)
        {
            var rval = new SliceI32();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceI32 From(int[] managed)
        {
            var rval = new SliceI32();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<int> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceI32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceI32 ToManaged()
            {
                return SliceI32.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceI32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceI32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceI32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceI32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceI32Extensions
        {
            public static SliceI32 Slice(this int[] s) { return SliceI32.From(s); }
        }


    public partial class SliceU32
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceU32 : IEnumerable<uint>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<uint> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe uint this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<uint>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<uint>()));
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceU32() { }

        public static SliceU32 From(IntPtr data, ulong len)
        {
            var rval = new SliceU32();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceU32 From(uint[] managed)
        {
            var rval = new SliceU32();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<uint> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceU32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceU32 ToManaged()
            {
                return SliceU32.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceU32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceU32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceU32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceU32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceU32Extensions
        {
            public static SliceU32 Slice(this uint[] s) { return SliceU32.From(s); }
        }


    public partial class SliceU8
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceU8 : IEnumerable<byte>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<byte> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe byte this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()));
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceU8() { }

        public static SliceU8 From(IntPtr data, ulong len)
        {
            var rval = new SliceU8();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceU8 From(byte[] managed)
        {
            var rval = new SliceU8();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceU8 ToManaged()
            {
                return SliceU8.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceU8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceU8 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceU8Extensions
        {
            public static SliceU8 Slice(this byte[] s) { return SliceU8.From(s); }
        }


    public partial class SliceUseCStrPtr
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceUseCStrPtr : IEnumerable<UseCStrPtr>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<UseCStrPtr> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe UseCStrPtr this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<UseCStrPtr>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<UseCStrPtr>()));
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceUseCStrPtr() { }

        public static SliceUseCStrPtr From(IntPtr data, ulong len)
        {
            var rval = new SliceUseCStrPtr();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceUseCStrPtr From(UseCStrPtr[] managed)
        {
            var rval = new SliceUseCStrPtr();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<UseCStrPtr> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceUseCStrPtr), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceUseCStrPtr ToManaged()
            {
                return SliceUseCStrPtr.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceUseCStrPtr _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceUseCStrPtr managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceUseCStrPtr managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceUseCStrPtr ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceUseCStrPtrExtensions
        {
            public static SliceUseCStrPtr Slice(this UseCStrPtr[] s) { return SliceUseCStrPtr.From(s); }
        }


    public partial class SliceUseString
    {
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceUseString : IDisposable
    {
        public int Count => (int) _len;

        public unsafe UseString this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= (int) _len) throw new IndexOutOfRangeException();
                if (_data == IntPtr.Zero) { throw new Exception(); }
                // TODO
                throw new Exception();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceUseString() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe SliceUseString From(UseString[] managed)
        {
            var rval = new SliceUseString();
            var size = sizeof(UseString.Unmanaged);
            rval._data  = Marshal.AllocHGlobal(size * managed.Length);
            rval._len = (ulong) managed.Length;
            for (var i = 0; i < managed.Length; ++i)
            {
                var unmanaged = managed[i].AsUnmanaged();
                var dst = IntPtr.Add(rval._data, i * size);
                Marshal.StructureToPtr(unmanaged, dst, false);
            }
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_data == IntPtr.Zero) return;
            Marshal.FreeHGlobal(_data);
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceUseString), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe SliceUseString ToManaged()
            {
                var _managed = new SliceUseString();
                _managed._data = _data;
                _managed._len = _len;
                return _managed;
            }

        }

        public ref struct Marshaller
        {
            private SliceUseString _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceUseString managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceUseString managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceUseString ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceUseStringExtensions
        {
            public static SliceUseString Slice(this UseString[] s) { return SliceUseString.From(s); }
        }


    public partial class SliceUtf8String
    {
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceUtf8String : IDisposable
    {
        public int Count => (int) _len;

        public unsafe Utf8String this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= (int) _len) throw new IndexOutOfRangeException();
                if (_data == IntPtr.Zero) { throw new Exception(); }
                // TODO
                throw new Exception();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceUtf8String() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe SliceUtf8String From(Utf8String[] managed)
        {
            var rval = new SliceUtf8String();
            var size = sizeof(Utf8String.Unmanaged);
            rval._data  = Marshal.AllocHGlobal(size * managed.Length);
            rval._len = (ulong) managed.Length;
            for (var i = 0; i < managed.Length; ++i)
            {
                var unmanaged = managed[i].AsUnmanaged();
                var dst = IntPtr.Add(rval._data, i * size);
                Marshal.StructureToPtr(unmanaged, dst, false);
            }
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_data == IntPtr.Zero) return;
            Marshal.FreeHGlobal(_data);
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceUtf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal unsafe SliceUtf8String ToManaged()
            {
                var _managed = new SliceUtf8String();
                _managed._data = _data;
                _managed._len = _len;
                return _managed;
            }

        }

        public ref struct Marshaller
        {
            private SliceUtf8String _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceUtf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceUtf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceUtf8String ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceUtf8StringExtensions
        {
            public static SliceUtf8String Slice(this Utf8String[] s) { return SliceUtf8String.From(s); }
        }


    public partial class SliceVec3f32
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceVec3f32 : IEnumerable<Vec3f32>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<Vec3f32> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe Vec3f32 this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<Vec3f32>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<Vec3f32>()));
            }

        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceVec3f32() { }

        public static SliceVec3f32 From(IntPtr data, ulong len)
        {
            var rval = new SliceVec3f32();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceVec3f32 From(Vec3f32[] managed)
        {
            var rval = new SliceVec3f32();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<Vec3f32> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceVec3f32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceVec3f32 ToManaged()
            {
                return SliceVec3f32.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceVec3f32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceVec3f32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceVec3f32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceVec3f32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceVec3f32Extensions
        {
            public static SliceVec3f32 Slice(this Vec3f32[] s) { return SliceVec3f32.From(s); }
        }


    public partial class SliceMutCharArray
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceMutCharArray : IEnumerable<CharArray>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<CharArray> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe CharArray this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<CharArray>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<CharArray>()));
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            set
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                Unsafe.Write<CharArray>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<CharArray>()), value);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceMutCharArray() { }

        public static SliceMutCharArray From(IntPtr data, ulong len)
        {
            var rval = new SliceMutCharArray();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceMutCharArray From(CharArray[] managed)
        {
            var rval = new SliceMutCharArray();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<CharArray> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceMutCharArray), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceMutCharArray ToManaged()
            {
                return SliceMutCharArray.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceMutCharArray _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceMutCharArray managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceMutCharArray managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceMutCharArray ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceMutCharArrayExtensions
        {
            public static SliceMutCharArray SliceMut(this CharArray[] s) { return SliceMutCharArray.From(s); }
        }


    public partial class SliceMutU32
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceMutU32 : IEnumerable<uint>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<uint> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe uint this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<uint>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<uint>()));
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            set
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                Unsafe.Write<uint>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<uint>()), value);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceMutU32() { }

        public static SliceMutU32 From(IntPtr data, ulong len)
        {
            var rval = new SliceMutU32();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceMutU32 From(uint[] managed)
        {
            var rval = new SliceMutU32();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<uint> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceMutU32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceMutU32 ToManaged()
            {
                return SliceMutU32.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceMutU32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceMutU32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceMutU32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceMutU32 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceMutU32Extensions
        {
            public static SliceMutU32 SliceMut(this uint[] s) { return SliceMutU32.From(s); }
        }


    public partial class SliceMutU8
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SliceMutU8 : IEnumerable<byte>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<byte> ReadOnlySpan
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe byte this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()));
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            set
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                Unsafe.Write<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()), value);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        SliceMutU8() { }

        public static SliceMutU8 From(IntPtr data, ulong len)
        {
            var rval = new SliceMutU8();
            rval._data = data;
            rval._len = len;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static SliceMutU8 From(byte[] managed)
        {
            var rval = new SliceMutU8();
            rval._handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            rval._data = rval._handle.AddrOfPinnedObject();
            rval._len = (ulong) managed.Length;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
            _data = IntPtr.Zero;
        }

        internal Unmanaged ToUnmanaged()
        {
            var unmanaged = new Unmanaged();
            unmanaged._data = _data;
            unmanaged._len = _len; 
            return unmanaged;
        }


        [CustomMarshaller(typeof(SliceMutU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr _data;
            public ulong _len;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal SliceMutU8 ToManaged()
            {
                return SliceMutU8.From(_data, _len);
            }
        }

        public ref struct Marshaller
        {
            private SliceMutU8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SliceMutU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SliceMutU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SliceMutU8 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

        public static class SliceMutU8Extensions
        {
            public static SliceMutU8 SliceMut(this byte[] s) { return SliceMutU8.From(s); }
        }


    ///Option that contains Some(value) or None.
    public partial struct OptionEnumPayload
    {
        uint _variant;
        EnumPayload _Some;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct OptionEnumPayload 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedSome
        {
            internal uint _variant;
            internal EnumPayload.Unmanaged _Some;
        }



        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedSome _Some;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal OptionEnumPayload ToManaged()
            {
                var _managed = new OptionEnumPayload();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Some = _Some._Some.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.ToUnmanaged();
            return _unmanaged;
        }

        public static OptionEnumPayload Some(EnumPayload value) => new() { _variant = 0, _Some = value };
        public static OptionEnumPayload None => new() { _variant = 1 };

        public bool IsSome => _variant == 0;
        public bool IsNone => _variant == 1;

        public EnumPayload AsSome() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Some; } }
        public void AsNone() { if (_variant != 1) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return $"Some({AsSome().ToString()})";
            if (_variant == 1) return "None";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<EnumPayload>(_Some);
            if (_variant == 1) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(OptionEnumPayload), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private OptionEnumPayload _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(OptionEnumPayload managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(OptionEnumPayload managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public OptionEnumPayload ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Option that contains Some(value) or None.
    public partial struct OptionInner
    {
        uint _variant;
        Inner _Some;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct OptionInner 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedSome
        {
            internal uint _variant;
            internal Inner.Unmanaged _Some;
        }



        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedSome _Some;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal OptionInner ToManaged()
            {
                var _managed = new OptionInner();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Some = _Some._Some.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.ToUnmanaged();
            return _unmanaged;
        }

        public static OptionInner Some(Inner value) => new() { _variant = 0, _Some = value };
        public static OptionInner None => new() { _variant = 1 };

        public bool IsSome => _variant == 0;
        public bool IsNone => _variant == 1;

        public Inner AsSome() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Some; } }
        public void AsNone() { if (_variant != 1) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Some(...)";
            if (_variant == 1) return "None";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<Inner>(_Some);
            if (_variant == 1) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(OptionInner), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private OptionInner _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(OptionInner managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(OptionInner managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public OptionInner ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Option that contains Some(value) or None.
    public partial class OptionOptionResultOptionUtf8StringError
    {
        uint _variant;
        OptionResultOptionUtf8StringError _Some;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class OptionOptionResultOptionUtf8StringError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedSome
        {
            internal uint _variant;
            internal OptionResultOptionUtf8StringError.Unmanaged _Some;
        }


        public void Dispose()
        {
            if (_variant == 0) { _Some.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedSome _Some;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal OptionOptionResultOptionUtf8StringError IntoManaged()
            {
                var _managed = new OptionOptionResultOptionUtf8StringError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Some = _Some._Some.IntoManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.AsUnmanaged();
            return _unmanaged;
        }

        public static OptionOptionResultOptionUtf8StringError Some(OptionResultOptionUtf8StringError value) => new() { _variant = 0, _Some = value };
        public static OptionOptionResultOptionUtf8StringError None => new() { _variant = 1 };

        public bool IsSome => _variant == 0;
        public bool IsNone => _variant == 1;

        public OptionResultOptionUtf8StringError AsSome() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Some; } }
        public void AsNone() { if (_variant != 1) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Some(...)";
            if (_variant == 1) return "None";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<OptionResultOptionUtf8StringError>(_Some);
            if (_variant == 1) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(OptionOptionResultOptionUtf8StringError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private OptionOptionResultOptionUtf8StringError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(OptionOptionResultOptionUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(OptionOptionResultOptionUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public OptionOptionResultOptionUtf8StringError ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Option that contains Some(value) or None.
    public partial class OptionResultOptionUtf8StringError
    {
        uint _variant;
        ResultOptionUtf8StringError _Some;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class OptionResultOptionUtf8StringError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedSome
        {
            internal uint _variant;
            internal ResultOptionUtf8StringError.Unmanaged _Some;
        }


        public void Dispose()
        {
            if (_variant == 0) { _Some.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedSome _Some;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal OptionResultOptionUtf8StringError IntoManaged()
            {
                var _managed = new OptionResultOptionUtf8StringError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Some = _Some._Some.IntoManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.AsUnmanaged();
            return _unmanaged;
        }

        public static OptionResultOptionUtf8StringError Some(ResultOptionUtf8StringError value) => new() { _variant = 0, _Some = value };
        public static OptionResultOptionUtf8StringError None => new() { _variant = 1 };

        public bool IsSome => _variant == 0;
        public bool IsNone => _variant == 1;

        public ResultOptionUtf8StringError AsSome() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Some; } }
        public void AsNone() { if (_variant != 1) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Some(...)";
            if (_variant == 1) return "None";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<ResultOptionUtf8StringError>(_Some);
            if (_variant == 1) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(OptionResultOptionUtf8StringError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private OptionResultOptionUtf8StringError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(OptionResultOptionUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(OptionResultOptionUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public OptionResultOptionUtf8StringError ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Option that contains Some(value) or None.
    public partial class OptionUtf8String
    {
        uint _variant;
        Utf8String _Some;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class OptionUtf8String : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedSome
        {
            internal uint _variant;
            internal Utf8String.Unmanaged _Some;
        }


        public void Dispose()
        {
            if (_variant == 0) { _Some.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedSome _Some;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal OptionUtf8String IntoManaged()
            {
                var _managed = new OptionUtf8String();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Some = _Some._Some.IntoManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.IntoUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Some._Some = _Some.AsUnmanaged();
            return _unmanaged;
        }

        public static OptionUtf8String Some(Utf8String value) => new() { _variant = 0, _Some = value };
        public static OptionUtf8String None => new() { _variant = 1 };

        public bool IsSome => _variant == 0;
        public bool IsNone => _variant == 1;

        public Utf8String AsSome() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Some; } }
        public void AsNone() { if (_variant != 1) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Some(...)";
            if (_variant == 1) return "None";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<Utf8String>(_Some);
            if (_variant == 1) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(OptionUtf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private OptionUtf8String _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(OptionUtf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(OptionUtf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public OptionUtf8String ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceAsyncBasicError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceAsyncBasicError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceAsyncBasicError ToManaged()
            {
                var _managed = new ResultConstPtrServiceAsyncBasicError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceAsyncBasicError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceAsyncBasicError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceAsyncBasicError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceAsyncBasicError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceAsyncBasicError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceAsyncBasicError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceAsyncBasicError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceAsyncBasicError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceAsyncBasicError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceAsyncResultError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceAsyncResultError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceAsyncResultError ToManaged()
            {
                var _managed = new ResultConstPtrServiceAsyncResultError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceAsyncResultError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceAsyncResultError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceAsyncResultError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceAsyncResultError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceAsyncResultError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceAsyncResultError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceAsyncResultError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceAsyncResultError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceAsyncResultError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceAsyncSleepError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceAsyncSleepError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceAsyncSleepError ToManaged()
            {
                var _managed = new ResultConstPtrServiceAsyncSleepError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceAsyncSleepError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceAsyncSleepError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceAsyncSleepError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceAsyncSleepError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceAsyncSleepError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceAsyncSleepError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceAsyncSleepError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceAsyncSleepError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceAsyncSleepError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceAsyncStructsError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceAsyncStructsError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceAsyncStructsError ToManaged()
            {
                var _managed = new ResultConstPtrServiceAsyncStructsError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceAsyncStructsError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceAsyncStructsError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceAsyncStructsError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceAsyncStructsError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceAsyncStructsError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceAsyncStructsError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceAsyncStructsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceAsyncStructsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceAsyncStructsError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceAsyncVecStringError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceAsyncVecStringError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceAsyncVecStringError ToManaged()
            {
                var _managed = new ResultConstPtrServiceAsyncVecStringError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceAsyncVecStringError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceAsyncVecStringError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceAsyncVecStringError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceAsyncVecStringError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceAsyncVecStringError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceAsyncVecStringError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceAsyncVecStringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceAsyncVecStringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceAsyncVecStringError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceBasicError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceBasicError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceBasicError ToManaged()
            {
                var _managed = new ResultConstPtrServiceBasicError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceBasicError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceBasicError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceBasicError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceBasicError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceBasicError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceBasicError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceBasicError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceBasicError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceBasicError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceCallbacksError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceCallbacksError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceCallbacksError ToManaged()
            {
                var _managed = new ResultConstPtrServiceCallbacksError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceCallbacksError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceCallbacksError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceCallbacksError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceCallbacksError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceCallbacksError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceCallbacksError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceCallbacksError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceCallbacksError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceCallbacksError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceDependentError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceDependentError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceDependentError ToManaged()
            {
                var _managed = new ResultConstPtrServiceDependentError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceDependentError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceDependentError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceDependentError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceDependentError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceDependentError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceDependentError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceDependentError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceDependentError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceDependentError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceIgnoringMethodsError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceIgnoringMethodsError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceIgnoringMethodsError ToManaged()
            {
                var _managed = new ResultConstPtrServiceIgnoringMethodsError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceIgnoringMethodsError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceIgnoringMethodsError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceIgnoringMethodsError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceIgnoringMethodsError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceIgnoringMethodsError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceIgnoringMethodsError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceIgnoringMethodsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceIgnoringMethodsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceIgnoringMethodsError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceMainError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceMainError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceMainError ToManaged()
            {
                var _managed = new ResultConstPtrServiceMainError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceMainError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceMainError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceMainError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceMainError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceMainError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceMainError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceMainError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceMainError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceMainError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceMultipleCtorsError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceMultipleCtorsError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceMultipleCtorsError ToManaged()
            {
                var _managed = new ResultConstPtrServiceMultipleCtorsError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceMultipleCtorsError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceMultipleCtorsError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceMultipleCtorsError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceMultipleCtorsError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceMultipleCtorsError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceMultipleCtorsError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceMultipleCtorsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceMultipleCtorsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceMultipleCtorsError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceOnPanicError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceOnPanicError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceOnPanicError ToManaged()
            {
                var _managed = new ResultConstPtrServiceOnPanicError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceOnPanicError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceOnPanicError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceOnPanicError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceOnPanicError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceOnPanicError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceOnPanicError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceOnPanicError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceOnPanicError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceOnPanicError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceResultError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceResultError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceResultError ToManaged()
            {
                var _managed = new ResultConstPtrServiceResultError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceResultError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceResultError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceResultError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceResultError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceResultError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceResultError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceResultError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceResultError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceResultError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceStringsError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceStringsError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceStringsError ToManaged()
            {
                var _managed = new ResultConstPtrServiceStringsError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceStringsError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceStringsError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceStringsError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceStringsError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceStringsError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceStringsError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceStringsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceStringsError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceStringsError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultConstPtrServiceVariousSlicesError
    {
        uint _variant;
        IntPtr _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultConstPtrServiceVariousSlicesError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal IntPtr _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultConstPtrServiceVariousSlicesError ToManaged()
            {
                var _managed = new ResultConstPtrServiceVariousSlicesError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultConstPtrServiceVariousSlicesError Ok(IntPtr value) => new() { _variant = 0, _Ok = value };
        public static ResultConstPtrServiceVariousSlicesError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultConstPtrServiceVariousSlicesError Panic => new() { _variant = 2 };
        public static ResultConstPtrServiceVariousSlicesError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public IntPtr AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<IntPtr>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultConstPtrServiceVariousSlicesError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultConstPtrServiceVariousSlicesError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultConstPtrServiceVariousSlicesError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultConstPtrServiceVariousSlicesError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultConstPtrServiceVariousSlicesError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultError
    {
        uint _variant;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultError 
    {

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultError ToManaged()
            {
                var _managed = new ResultError();
                _managed._variant = _variant;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultError Ok => new() { _variant = 0 };
        public static ResultError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultError Panic => new() { _variant = 2 };
        public static ResultError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public void AsOk() { if (_variant != 0) throw ExceptionForVariant(); }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException();
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultNestedArrayError
    {
        uint _variant;
        NestedArray _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultNestedArrayError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal NestedArray.Unmanaged _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultNestedArrayError ToManaged()
            {
                var _managed = new ResultNestedArrayError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok.ToManaged();
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.ToUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.ToUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultNestedArrayError Ok(NestedArray value) => new() { _variant = 0, _Ok = value };
        public static ResultNestedArrayError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultNestedArrayError Panic => new() { _variant = 2 };
        public static ResultNestedArrayError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public NestedArray AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<NestedArray>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultNestedArrayError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultNestedArrayError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultNestedArrayError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultNestedArrayError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultNestedArrayError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultOptionEnumPayloadError
    {
        uint _variant;
        OptionEnumPayload _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultOptionEnumPayloadError 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal OptionEnumPayload.Unmanaged _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultOptionEnumPayloadError ToManaged()
            {
                var _managed = new ResultOptionEnumPayloadError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok.ToManaged();
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.ToUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.ToUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultOptionEnumPayloadError Ok(OptionEnumPayload value) => new() { _variant = 0, _Ok = value };
        public static ResultOptionEnumPayloadError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultOptionEnumPayloadError Panic => new() { _variant = 2 };
        public static ResultOptionEnumPayloadError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public OptionEnumPayload AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<OptionEnumPayload>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultOptionEnumPayloadError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultOptionEnumPayloadError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultOptionEnumPayloadError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultOptionEnumPayloadError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultOptionEnumPayloadError ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial class ResultOptionUtf8StringError
    {
        uint _variant;
        OptionUtf8String _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class ResultOptionUtf8StringError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal OptionUtf8String.Unmanaged _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }



        public void Dispose()
        {
            if (_variant == 0) { _Ok.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultOptionUtf8StringError IntoManaged()
            {
                var _managed = new ResultOptionUtf8StringError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok.IntoManaged();
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.IntoUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.AsUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultOptionUtf8StringError Ok(OptionUtf8String value) => new() { _variant = 0, _Ok = value };
        public static ResultOptionUtf8StringError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultOptionUtf8StringError Panic => new() { _variant = 2 };
        public static ResultOptionUtf8StringError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public OptionUtf8String AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<OptionUtf8String>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultOptionUtf8StringError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultOptionUtf8StringError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultOptionUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultOptionUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultOptionUtf8StringError ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultU32Error
    {
        uint _variant;
        uint _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultU32Error 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal uint _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultU32Error ToManaged()
            {
                var _managed = new ResultU32Error();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultU32Error Ok(uint value) => new() { _variant = 0, _Ok = value };
        public static ResultU32Error Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultU32Error Panic => new() { _variant = 2 };
        public static ResultU32Error Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public uint AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<uint>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultU32Error), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultU32Error _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultU32Error managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultU32Error managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultU32Error ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultU64Error
    {
        uint _variant;
        ulong _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultU64Error 
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal ulong _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }




        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultU64Error ToManaged()
            {
                var _managed = new ResultU64Error();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok;
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok;
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultU64Error Ok(ulong value) => new() { _variant = 0, _Ok = value };
        public static ResultU64Error Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultU64Error Panic => new() { _variant = 2 };
        public static ResultU64Error Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public ulong AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<ulong>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultU64Error), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultU64Error _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultU64Error managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultU64Error managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultU64Error ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial class ResultUseStringError
    {
        uint _variant;
        UseString _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class ResultUseStringError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal UseString.Unmanaged _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }



        public void Dispose()
        {
            if (_variant == 0) { _Ok.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultUseStringError IntoManaged()
            {
                var _managed = new ResultUseStringError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok.IntoManaged();
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.IntoUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.AsUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultUseStringError Ok(UseString value) => new() { _variant = 0, _Ok = value };
        public static ResultUseStringError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultUseStringError Panic => new() { _variant = 2 };
        public static ResultUseStringError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public UseString AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<UseString>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultUseStringError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultUseStringError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultUseStringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultUseStringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultUseStringError ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial class ResultUtf8StringError
    {
        uint _variant;
        Utf8String _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class ResultUtf8StringError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal Utf8String.Unmanaged _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }



        public void Dispose()
        {
            if (_variant == 0) { _Ok.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultUtf8StringError IntoManaged()
            {
                var _managed = new ResultUtf8StringError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok.IntoManaged();
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.IntoUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.AsUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultUtf8StringError Ok(Utf8String value) => new() { _variant = 0, _Ok = value };
        public static ResultUtf8StringError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultUtf8StringError Panic => new() { _variant = 2 };
        public static ResultUtf8StringError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public Utf8String AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<Utf8String>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultUtf8StringError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultUtf8StringError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultUtf8StringError ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial class ResultVecUtf8StringError
    {
        uint _variant;
        VecUtf8String _Ok;
        Error _Err;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class ResultVecUtf8StringError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedOk
        {
            internal uint _variant;
            internal VecUtf8String.Unmanaged _Ok;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct UnmanagedErr
        {
            internal uint _variant;
            internal Error.Unmanaged _Err;
        }



        public void Dispose()
        {
            if (_variant == 0) { _Ok.Dispose(); }
        }

        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [FieldOffset(0)]
            internal UnmanagedOk _Ok;

            [FieldOffset(0)]
            internal UnmanagedErr _Err;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultVecUtf8StringError IntoManaged()
            {
                var _managed = new ResultVecUtf8StringError();
                _managed._variant = _variant;
                if (_variant == 0) _managed._Ok = _Ok._Ok.IntoManaged();
                if (_variant == 1) _managed._Err = _Err._Err.ToManaged();
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged IntoUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.IntoUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            if (_variant == 0) _unmanaged._Ok._Ok = _Ok.AsUnmanaged();
            if (_variant == 1) _unmanaged._Err._Err = _Err.ToUnmanaged();
            return _unmanaged;
        }

        public static ResultVecUtf8StringError Ok(VecUtf8String value) => new() { _variant = 0, _Ok = value };
        public static ResultVecUtf8StringError Err(Error value) => new() { _variant = 1, _Err = value };
        public static ResultVecUtf8StringError Panic => new() { _variant = 2 };
        public static ResultVecUtf8StringError Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public VecUtf8String AsOk() { if (_variant != 0) { throw ExceptionForVariant(); } else { return _Ok; } }
        public Error AsErr() { if (_variant != 1) { throw ExceptionForVariant(); } else { return _Err; } }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return $"Err({AsErr().ToString()})";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException<VecUtf8String>(_Ok);
            if (_variant == 1) return new EnumException<Error>(_Err);
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultVecUtf8StringError), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultVecUtf8StringError _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultVecUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultVecUtf8StringError managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultVecUtf8StringError ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    ///Result that contains value or an error.
    public partial struct ResultVoid
    {
        uint _variant;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct ResultVoid 
    {





        [StructLayout(LayoutKind.Explicit)]
        public unsafe struct Unmanaged
        {
            [FieldOffset(0)]
            internal uint _variant;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            internal ResultVoid ToManaged()
            {
                var _managed = new ResultVoid();
                _managed._variant = _variant;
                return _managed;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._variant = _variant;
            return _unmanaged;
        }

        public static ResultVoid Ok => new() { _variant = 0 };
        public static ResultVoid Err => new() { _variant = 1 };
        public static ResultVoid Panic => new() { _variant = 2 };
        public static ResultVoid Null => new() { _variant = 3 };

        public bool IsOk => _variant == 0;
        public bool IsErr => _variant == 1;
        public bool IsPanic => _variant == 2;
        public bool IsNull => _variant == 3;

        public void AsOk() { if (_variant != 0) throw ExceptionForVariant(); }
        public void AsErr() { if (_variant != 1) throw ExceptionForVariant(); }
        public void AsPanic() { if (_variant != 2) throw ExceptionForVariant(); }
        public void AsNull() { if (_variant != 3) throw ExceptionForVariant(); }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            if (_variant == 0) return "Ok(...)";
            if (_variant == 1) return "Err(...)";
            if (_variant == 2) return "Panic";
            if (_variant == 3) return "Null";
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Exception ExceptionForVariant()
        {
            if (_variant == 0) return new EnumException();
            if (_variant == 1) return new EnumException();
            if (_variant == 2) return new EnumException();
            if (_variant == 3) return new EnumException();
            throw new InteropException("Illegal enum state detected. This is a severe error and should never happen.");
        }

        [CustomMarshaller(typeof(ResultVoid), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private ResultVoid _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(ResultVoid managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(ResultVoid managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public ResultVoid ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Bool
    {
        byte value;
    }

    public partial struct Bool
    {
        public static readonly Bool True = new Bool { value =  1 };
        public static readonly Bool False = new Bool { value =  0 };
        public Bool(bool b)
        {
            value = (byte) (b ? 1 : 0);
        }
        public bool Is => value == 1;
    }


    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void CallbackCharArray2Native(CharArray.Unmanaged value, IntPtr callback_data); // 'True' native callback signature
    public delegate void CallbackCharArray2Delegate(CharArray value); // Our C# signature

    public partial class CallbackCharArray2
    {
        private CallbackCharArray2Delegate _managed; // C# callback
        private CallbackCharArray2Native _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class CallbackCharArray2 : IDisposable
    {

        internal CallbackCharArray2() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public CallbackCharArray2(CallbackCharArray2Delegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(CharArray.Unmanaged value, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(value.ToManaged());
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(CharArray value)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<CallbackCharArray2Native>(_ptr);
            // TODO
            // __target(value.ToManaged());
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(CallbackCharArray2), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public CallbackCharArray2 ToManaged()
            {
                var rval = new CallbackCharArray2();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private CallbackCharArray2 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CallbackCharArray2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CallbackCharArray2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CallbackCharArray2 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate byte CallbackFFISliceNative(SliceU8.Unmanaged slice, IntPtr callback_data); // 'True' native callback signature
    public delegate byte CallbackFFISliceDelegate(SliceU8 slice); // Our C# signature

    public partial class CallbackFFISlice
    {
        private CallbackFFISliceDelegate _managed; // C# callback
        private CallbackFFISliceNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class CallbackFFISlice : IDisposable
    {

        internal CallbackFFISlice() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public CallbackFFISlice(CallbackFFISliceDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private byte CallTrampoline(SliceU8.Unmanaged slice, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                return _managed(slice.ToManaged());
            }
            catch (Exception e)
            {
                _exception = e;
                return default;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal byte Call(SliceU8 slice)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<CallbackFFISliceNative>(_ptr);
            // TODO
            // return __target(slice.ToManaged());
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(CallbackFFISlice), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public CallbackFFISlice ToManaged()
            {
                var rval = new CallbackFFISlice();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private CallbackFFISlice _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CallbackFFISlice managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CallbackFFISlice managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CallbackFFISlice ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate Vec3f32.Unmanaged CallbackHugeVecSliceNative(SliceVec3f32.Unmanaged slice, IntPtr callback_data); // 'True' native callback signature
    public delegate Vec3f32 CallbackHugeVecSliceDelegate(SliceVec3f32 slice); // Our C# signature

    public partial class CallbackHugeVecSlice
    {
        private CallbackHugeVecSliceDelegate _managed; // C# callback
        private CallbackHugeVecSliceNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class CallbackHugeVecSlice : IDisposable
    {

        internal CallbackHugeVecSlice() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public CallbackHugeVecSlice(CallbackHugeVecSliceDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private Vec3f32.Unmanaged CallTrampoline(SliceVec3f32.Unmanaged slice, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                return _managed(slice.ToManaged()).ToUnmanaged();
            }
            catch (Exception e)
            {
                _exception = e;
                return default;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Vec3f32 Call(SliceVec3f32 slice)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<CallbackHugeVecSliceNative>(_ptr);
            // TODO
            // return __target(slice.ToManaged());
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(CallbackHugeVecSlice), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public CallbackHugeVecSlice ToManaged()
            {
                var rval = new CallbackHugeVecSlice();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private CallbackHugeVecSlice _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CallbackHugeVecSlice managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CallbackHugeVecSlice managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CallbackHugeVecSlice ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void CallbackSliceMutNative(SliceMutU8.Unmanaged slice, IntPtr callback_data); // 'True' native callback signature
    public delegate void CallbackSliceMutDelegate(SliceMutU8 slice); // Our C# signature

    public partial class CallbackSliceMut
    {
        private CallbackSliceMutDelegate _managed; // C# callback
        private CallbackSliceMutNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class CallbackSliceMut : IDisposable
    {

        internal CallbackSliceMut() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public CallbackSliceMut(CallbackSliceMutDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(SliceMutU8.Unmanaged slice, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(slice.ToManaged());
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(SliceMutU8 slice)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<CallbackSliceMutNative>(_ptr);
            // TODO
            // __target(slice.ToManaged());
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(CallbackSliceMut), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public CallbackSliceMut ToManaged()
            {
                var rval = new CallbackSliceMut();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private CallbackSliceMut _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CallbackSliceMut managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CallbackSliceMut managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CallbackSliceMut ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate byte CallbackU8Native(byte value, IntPtr callback_data); // 'True' native callback signature
    public delegate byte CallbackU8Delegate(byte value); // Our C# signature

    public partial class CallbackU8
    {
        private CallbackU8Delegate _managed; // C# callback
        private CallbackU8Native _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class CallbackU8 : IDisposable
    {

        internal CallbackU8() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public CallbackU8(CallbackU8Delegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private byte CallTrampoline(byte value, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                return _managed(value);
            }
            catch (Exception e)
            {
                _exception = e;
                return default;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal byte Call(byte value)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<CallbackU8Native>(_ptr);
            // TODO
            // return __target(value);
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(CallbackU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public CallbackU8 ToManaged()
            {
                var rval = new CallbackU8();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private CallbackU8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(CallbackU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(CallbackU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public CallbackU8 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate uint MyCallbackNative(uint value, IntPtr callback_data); // 'True' native callback signature
    public delegate uint MyCallbackDelegate(uint value); // Our C# signature

    public partial class MyCallback
    {
        private MyCallbackDelegate _managed; // C# callback
        private MyCallbackNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class MyCallback : IDisposable
    {

        internal MyCallback() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public MyCallback(MyCallbackDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private uint CallTrampoline(uint value, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                return _managed(value);
            }
            catch (Exception e)
            {
                _exception = e;
                return default;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal uint Call(uint value)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<MyCallbackNative>(_ptr);
            // TODO
            // return __target(value);
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(MyCallback), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public MyCallback ToManaged()
            {
                var rval = new MyCallback();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private MyCallback _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(MyCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(MyCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public MyCallback ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void MyCallbackContextualNative(IntPtr context, uint value, IntPtr callback_data); // 'True' native callback signature
    public delegate void MyCallbackContextualDelegate(IntPtr context, uint value); // Our C# signature

    public partial class MyCallbackContextual
    {
        private MyCallbackContextualDelegate _managed; // C# callback
        private MyCallbackContextualNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class MyCallbackContextual : IDisposable
    {

        internal MyCallbackContextual() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public MyCallbackContextual(MyCallbackContextualDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(IntPtr context, uint value, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(context, value);
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(IntPtr context, uint value)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<MyCallbackContextualNative>(_ptr);
            // TODO
            // __target(context, value);
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(MyCallbackContextual), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public MyCallbackContextual ToManaged()
            {
                var rval = new MyCallbackContextual();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private MyCallbackContextual _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(MyCallbackContextual managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(MyCallbackContextual managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public MyCallbackContextual ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void MyCallbackVoidNative(IntPtr ptr, IntPtr callback_data); // 'True' native callback signature
    public delegate void MyCallbackVoidDelegate(IntPtr ptr); // Our C# signature

    public partial class MyCallbackVoid
    {
        private MyCallbackVoidDelegate _managed; // C# callback
        private MyCallbackVoidNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class MyCallbackVoid : IDisposable
    {

        internal MyCallbackVoid() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public MyCallbackVoid(MyCallbackVoidDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(IntPtr ptr, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(ptr);
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(IntPtr ptr)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<MyCallbackVoidNative>(_ptr);
            // TODO
            // __target(ptr);
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(MyCallbackVoid), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public MyCallbackVoid ToManaged()
            {
                var rval = new MyCallbackVoid();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private MyCallbackVoid _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(MyCallbackVoid managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(MyCallbackVoid managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public MyCallbackVoid ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void NestedStringCallbackNative(UseString.Unmanaged s, IntPtr callback_data); // 'True' native callback signature
    public delegate void NestedStringCallbackDelegate(UseString s); // Our C# signature

    public partial class NestedStringCallback
    {
        private NestedStringCallbackDelegate _managed; // C# callback
        private NestedStringCallbackNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class NestedStringCallback : IDisposable
    {

        internal NestedStringCallback() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public NestedStringCallback(NestedStringCallbackDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(UseString.Unmanaged s, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(s.IntoManaged());
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(UseString s)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<NestedStringCallbackNative>(_ptr);
            // TODO
            // __target(s.IntoManaged());
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(NestedStringCallback), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public NestedStringCallback ToManaged()
            {
                var rval = new NestedStringCallback();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private NestedStringCallback _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(NestedStringCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(NestedStringCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public NestedStringCallback ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void StringCallbackNative(Utf8String.Unmanaged s, IntPtr callback_data); // 'True' native callback signature
    public delegate void StringCallbackDelegate(Utf8String s); // Our C# signature

    public partial class StringCallback
    {
        private StringCallbackDelegate _managed; // C# callback
        private StringCallbackNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class StringCallback : IDisposable
    {

        internal StringCallback() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public StringCallback(StringCallbackDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(Utf8String.Unmanaged s, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(s.IntoManaged());
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(Utf8String s)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<StringCallbackNative>(_ptr);
            // TODO
            // __target(s.IntoManaged());
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(StringCallback), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public StringCallback ToManaged()
            {
                var rval = new StringCallback();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private StringCallback _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(StringCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(StringCallback managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public StringCallback ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void SumDelegate1Native(IntPtr callback_data); // 'True' native callback signature
    public delegate void SumDelegate1Delegate(); // Our C# signature

    public partial class SumDelegate1
    {
        private SumDelegate1Delegate _managed; // C# callback
        private SumDelegate1Native _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SumDelegate1 : IDisposable
    {

        internal SumDelegate1() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public SumDelegate1(SumDelegate1Delegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed();
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call()
        {
            var __target = Marshal.GetDelegateForFunctionPointer<SumDelegate1Native>(_ptr);
            // TODO
            // __target();
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(SumDelegate1), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public SumDelegate1 ToManaged()
            {
                var rval = new SumDelegate1();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private SumDelegate1 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SumDelegate1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SumDelegate1 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SumDelegate1 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate int SumDelegate2Native(int x, int y, IntPtr callback_data); // 'True' native callback signature
    public delegate int SumDelegate2Delegate(int x, int y); // Our C# signature

    public partial class SumDelegate2
    {
        private SumDelegate2Delegate _managed; // C# callback
        private SumDelegate2Native _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SumDelegate2 : IDisposable
    {

        internal SumDelegate2() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public SumDelegate2(SumDelegate2Delegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private int CallTrampoline(int x, int y, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                return _managed(x, y);
            }
            catch (Exception e)
            {
                _exception = e;
                return default;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal int Call(int x, int y)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<SumDelegate2Native>(_ptr);
            // TODO
            // return __target(x, y);
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(SumDelegate2), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public SumDelegate2 ToManaged()
            {
                var rval = new SumDelegate2();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private SumDelegate2 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SumDelegate2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SumDelegate2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SumDelegate2 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate ResultError.Unmanaged SumDelegateReturnNative(int x, int y, IntPtr callback_data); // 'True' native callback signature
    public delegate ResultError SumDelegateReturnDelegate(int x, int y); // Our C# signature

    public partial class SumDelegateReturn
    {
        private SumDelegateReturnDelegate _managed; // C# callback
        private SumDelegateReturnNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SumDelegateReturn : IDisposable
    {

        internal SumDelegateReturn() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public SumDelegateReturn(SumDelegateReturnDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private ResultError.Unmanaged CallTrampoline(int x, int y, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                return _managed(x, y).ToUnmanaged();
            }
            catch (Exception e)
            {
                _exception = e;
                return default;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal ResultError Call(int x, int y)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<SumDelegateReturnNative>(_ptr);
            // TODO
            // return __target(x, y);
            return default;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(SumDelegateReturn), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public SumDelegateReturn ToManaged()
            {
                var rval = new SumDelegateReturn();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private SumDelegateReturn _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SumDelegateReturn managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SumDelegateReturn managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SumDelegateReturn ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void SumDelegateReturn2Native(int x, int y, IntPtr callback_data); // 'True' native callback signature
    public delegate void SumDelegateReturn2Delegate(int x, int y); // Our C# signature

    public partial class SumDelegateReturn2
    {
        private SumDelegateReturn2Delegate _managed; // C# callback
        private SumDelegateReturn2Native _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class SumDelegateReturn2 : IDisposable
    {

        internal SumDelegateReturn2() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public SumDelegateReturn2(SumDelegateReturn2Delegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private void CallTrampoline(int x, int y, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                _managed(x, y);
            }
            catch (Exception e)
            {
                _exception = e;
                return;
            }
        }

        // Invokes the callback.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal void Call(int x, int y)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<SumDelegateReturn2Native>(_ptr);
            // TODO
            // __target(x, y);
            return;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal Unmanaged ToUnmanaged()
        {
            var rval = new Unmanaged();
            rval._callback = _ptr;
            rval._data = IntPtr.Zero;
            return rval;
        }

        [CustomMarshaller(typeof(SumDelegateReturn2), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _callback;
            internal IntPtr _data;

            public SumDelegateReturn2 ToManaged()
            {
                var rval = new SumDelegateReturn2();
                rval._ptr = _callback;
                return rval;
            }

        }

        public ref struct Marshaller
        {
            private SumDelegateReturn2 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(SumDelegateReturn2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(SumDelegateReturn2 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.ToUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public SumDelegateReturn2 ToManaged() { return _unmanaged.ToManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public class AsyncTrampolineResultError
    {
        private static ulong Id = 0;
        private static Dictionary<ulong, TaskCompletionSource> InFlight = new(1024);
        private AsyncCallbackCommon _delegate;
        private IntPtr _callback_ptr;

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal AsyncTrampolineResultError()
        {
            _delegate = Call;
            _callback_ptr = Marshal.GetFunctionPointerForDelegate(_delegate);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private static void Call(IntPtr data, IntPtr csPtr)
        {
            TaskCompletionSource tcs;
            
            lock (InFlight) { InFlight.Remove((ulong) csPtr, out tcs); }
            
            var unmanaged = Marshal.PtrToStructure<ResultError.Unmanaged>(data);
            var managed = unmanaged.ToManaged();
            if (managed.IsOk) { tcs.SetResult(); }
            else { tcs.SetException(managed.ExceptionForVariant()); }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal (AsyncCallbackCommonNative, Task) NewCall()
        {
            var tcs = new TaskCompletionSource();
            var id = Id++;
            
            lock (InFlight) { InFlight.TryAdd(id, tcs); }
            
            var ac = new AsyncCallbackCommonNative {
                _ptr = _callback_ptr,
                _ts = (IntPtr) id,
            };

            return (ac, tcs.Task);
        }
    }

    public class AsyncTrampolineResultNestedArrayError
    {
        private static ulong Id = 0;
        private static Dictionary<ulong, TaskCompletionSource<NestedArray>> InFlight = new(1024);
        private AsyncCallbackCommon _delegate;
        private IntPtr _callback_ptr;

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal AsyncTrampolineResultNestedArrayError()
        {
            _delegate = Call;
            _callback_ptr = Marshal.GetFunctionPointerForDelegate(_delegate);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private static void Call(IntPtr data, IntPtr csPtr)
        {
            TaskCompletionSource<NestedArray> tcs;
            
            lock (InFlight) { InFlight.Remove((ulong) csPtr, out tcs); }
            
            var unmanaged = Marshal.PtrToStructure<ResultNestedArrayError.Unmanaged>(data);
            var managed = unmanaged.ToManaged();
            if (managed.IsOk) { tcs.SetResult(managed.AsOk()); }
            else { tcs.SetException(managed.ExceptionForVariant()); }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal (AsyncCallbackCommonNative, Task<NestedArray>) NewCall()
        {
            var tcs = new TaskCompletionSource<NestedArray>();
            var id = Id++;
            
            lock (InFlight) { InFlight.TryAdd(id, tcs); }
            
            var ac = new AsyncCallbackCommonNative {
                _ptr = _callback_ptr,
                _ts = (IntPtr) id,
            };

            return (ac, tcs.Task);
        }
    }

    public class AsyncTrampolineResultU64Error
    {
        private static ulong Id = 0;
        private static Dictionary<ulong, TaskCompletionSource<ulong>> InFlight = new(1024);
        private AsyncCallbackCommon _delegate;
        private IntPtr _callback_ptr;

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal AsyncTrampolineResultU64Error()
        {
            _delegate = Call;
            _callback_ptr = Marshal.GetFunctionPointerForDelegate(_delegate);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private static void Call(IntPtr data, IntPtr csPtr)
        {
            TaskCompletionSource<ulong> tcs;
            
            lock (InFlight) { InFlight.Remove((ulong) csPtr, out tcs); }
            
            var unmanaged = Marshal.PtrToStructure<ResultU64Error.Unmanaged>(data);
            var managed = unmanaged.ToManaged();
            if (managed.IsOk) { tcs.SetResult(managed.AsOk()); }
            else { tcs.SetException(managed.ExceptionForVariant()); }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal (AsyncCallbackCommonNative, Task<ulong>) NewCall()
        {
            var tcs = new TaskCompletionSource<ulong>();
            var id = Id++;
            
            lock (InFlight) { InFlight.TryAdd(id, tcs); }
            
            var ac = new AsyncCallbackCommonNative {
                _ptr = _callback_ptr,
                _ts = (IntPtr) id,
            };

            return (ac, tcs.Task);
        }
    }

    public class AsyncTrampolineResultUseStringError
    {
        private static ulong Id = 0;
        private static Dictionary<ulong, TaskCompletionSource<UseString>> InFlight = new(1024);
        private AsyncCallbackCommon _delegate;
        private IntPtr _callback_ptr;

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal AsyncTrampolineResultUseStringError()
        {
            _delegate = Call;
            _callback_ptr = Marshal.GetFunctionPointerForDelegate(_delegate);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private static void Call(IntPtr data, IntPtr csPtr)
        {
            TaskCompletionSource<UseString> tcs;
            
            lock (InFlight) { InFlight.Remove((ulong) csPtr, out tcs); }
            
            var unmanaged = Marshal.PtrToStructure<ResultUseStringError.Unmanaged>(data);
            var managed = unmanaged.IntoManaged();
            if (managed.IsOk) { tcs.SetResult(managed.AsOk()); }
            else { tcs.SetException(managed.ExceptionForVariant()); }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal (AsyncCallbackCommonNative, Task<UseString>) NewCall()
        {
            var tcs = new TaskCompletionSource<UseString>();
            var id = Id++;
            
            lock (InFlight) { InFlight.TryAdd(id, tcs); }
            
            var ac = new AsyncCallbackCommonNative {
                _ptr = _callback_ptr,
                _ts = (IntPtr) id,
            };

            return (ac, tcs.Task);
        }
    }

    public class AsyncTrampolineResultUtf8StringError
    {
        private static ulong Id = 0;
        private static Dictionary<ulong, TaskCompletionSource<Utf8String>> InFlight = new(1024);
        private AsyncCallbackCommon _delegate;
        private IntPtr _callback_ptr;

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal AsyncTrampolineResultUtf8StringError()
        {
            _delegate = Call;
            _callback_ptr = Marshal.GetFunctionPointerForDelegate(_delegate);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private static void Call(IntPtr data, IntPtr csPtr)
        {
            TaskCompletionSource<Utf8String> tcs;
            
            lock (InFlight) { InFlight.Remove((ulong) csPtr, out tcs); }
            
            var unmanaged = Marshal.PtrToStructure<ResultUtf8StringError.Unmanaged>(data);
            var managed = unmanaged.IntoManaged();
            if (managed.IsOk) { tcs.SetResult(managed.AsOk()); }
            else { tcs.SetException(managed.ExceptionForVariant()); }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal (AsyncCallbackCommonNative, Task<Utf8String>) NewCall()
        {
            var tcs = new TaskCompletionSource<Utf8String>();
            var id = Id++;
            
            lock (InFlight) { InFlight.TryAdd(id, tcs); }
            
            var ac = new AsyncCallbackCommonNative {
                _ptr = _callback_ptr,
                _ts = (IntPtr) id,
            };

            return (ac, tcs.Task);
        }
    }

    public class AsyncTrampolineResultVecUtf8StringError
    {
        private static ulong Id = 0;
        private static Dictionary<ulong, TaskCompletionSource<VecUtf8String>> InFlight = new(1024);
        private AsyncCallbackCommon _delegate;
        private IntPtr _callback_ptr;

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal AsyncTrampolineResultVecUtf8StringError()
        {
            _delegate = Call;
            _callback_ptr = Marshal.GetFunctionPointerForDelegate(_delegate);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private static void Call(IntPtr data, IntPtr csPtr)
        {
            TaskCompletionSource<VecUtf8String> tcs;
            
            lock (InFlight) { InFlight.Remove((ulong) csPtr, out tcs); }
            
            var unmanaged = Marshal.PtrToStructure<ResultVecUtf8StringError.Unmanaged>(data);
            var managed = unmanaged.IntoManaged();
            if (managed.IsOk) { tcs.SetResult(managed.AsOk()); }
            else { tcs.SetException(managed.ExceptionForVariant()); }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        internal (AsyncCallbackCommonNative, Task<VecUtf8String>) NewCall()
        {
            var tcs = new TaskCompletionSource<VecUtf8String>();
            var id = Id++;
            
            lock (InFlight) { InFlight.TryAdd(id, tcs); }
            
            var ac = new AsyncCallbackCommonNative {
                _ptr = _callback_ptr,
                _ts = (IntPtr) id,
            };

            return (ac, tcs.Task);
        }
    }

    // This must be a class because we only ever want to hold on to the
    // same instance, as we overwrite fields when this is sent over the FFI
    // boundary
    public partial class VecEnumPayload
    {
        internal IntPtr _ptr;
        internal ulong _len;
        internal ulong _capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class VecEnumPayload : IDisposable
    {
        // An internal helper to create an empty object.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private VecEnumPayload() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecEnumPayload From(Span<EnumPayload> _data)
        {
            var rval = new VecEnumPayload();
            fixed (void* _data_ptr = _data)
            {
                InteropHelper.interoptopus_vec_create((IntPtr) _data_ptr, (ulong)_data.Length, out var _out);
                rval._len = _out._len;
                rval._capacity = _out._capacity;
                rval._ptr = _out._ptr;
            }
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecEnumPayload Empty()
        {
            InteropHelper.interoptopus_vec_create(IntPtr.Zero, 0, out var _out);
            return _out.IntoManaged();
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get { if (_ptr == IntPtr.Zero) { throw new NullReferenceException(); } else { return (int) _len; } }
        }

        public unsafe EnumPayload this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                if (_ptr == IntPtr.Zero) throw new NullReferenceException();
                return Marshal.PtrToStructure<EnumPayload>(new IntPtr(_ptr.ToInt64() + i * sizeof(EnumPayload)));
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged IntoUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            _ptr = IntPtr.Zero; // Mark this instance as moved.
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged AsUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            InteropHelper.interoptopus_vec_destroy(_unmanaged);
            _ptr = IntPtr.Zero;
            _len = 0;
            _capacity = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "VecEnumPayload { ... }";
        }


        public partial class InteropHelper
        {
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_create_12058709700293828778")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_create(IntPtr vec, ulong len, out Unmanaged rval);
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_destroy_4854562680055612543")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_destroy(Unmanaged vec);
        }

        [CustomMarshaller(typeof(VecEnumPayload), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _ptr;
            internal ulong _len;
            internal ulong _capacity;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecEnumPayload IntoManaged()
            {
                var rval = new VecEnumPayload();
                rval._len = _len;
                rval._capacity = _capacity;
                rval._ptr = _ptr;
                return rval;
            }


        }

        public ref struct Marshaller
        {
            private VecEnumPayload _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(VecEnumPayload managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(VecEnumPayload managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecEnumPayload ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public static class VecEnumPayloadExtensions
    {
        public static VecEnumPayload Vec(this EnumPayload[] s) { return VecEnumPayload.From(s); }
    }


    // This must be a class because we only ever want to hold on to the
    // same instance, as we overwrite fields when this is sent over the FFI
    // boundary
    public partial class VecU8
    {
        internal IntPtr _ptr;
        internal ulong _len;
        internal ulong _capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class VecU8 : IDisposable
    {
        // An internal helper to create an empty object.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private VecU8() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecU8 From(Span<byte> _data)
        {
            var rval = new VecU8();
            fixed (void* _data_ptr = _data)
            {
                InteropHelper.interoptopus_vec_create((IntPtr) _data_ptr, (ulong)_data.Length, out var _out);
                rval._len = _out._len;
                rval._capacity = _out._capacity;
                rval._ptr = _out._ptr;
            }
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecU8 Empty()
        {
            InteropHelper.interoptopus_vec_create(IntPtr.Zero, 0, out var _out);
            return _out.IntoManaged();
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get { if (_ptr == IntPtr.Zero) { throw new NullReferenceException(); } else { return (int) _len; } }
        }

        public unsafe byte this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                if (_ptr == IntPtr.Zero) throw new NullReferenceException();
                return Marshal.PtrToStructure<byte>(new IntPtr(_ptr.ToInt64() + i * sizeof(byte)));
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged IntoUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            _ptr = IntPtr.Zero; // Mark this instance as moved.
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged AsUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            InteropHelper.interoptopus_vec_destroy(_unmanaged);
            _ptr = IntPtr.Zero;
            _len = 0;
            _capacity = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "VecU8 { ... }";
        }


        public partial class InteropHelper
        {
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_create_6849152863081469284")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_create(IntPtr vec, ulong len, out Unmanaged rval);
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_destroy_9353420175730321243")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_destroy(Unmanaged vec);
        }

        [CustomMarshaller(typeof(VecU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _ptr;
            internal ulong _len;
            internal ulong _capacity;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecU8 IntoManaged()
            {
                var rval = new VecU8();
                rval._len = _len;
                rval._capacity = _capacity;
                rval._ptr = _ptr;
                return rval;
            }


        }

        public ref struct Marshaller
        {
            private VecU8 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(VecU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(VecU8 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecU8 ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public static class VecU8Extensions
    {
        public static VecU8 Vec(this byte[] s) { return VecU8.From(s); }
    }


    // This must be a class because we only ever want to hold on to the
    // same instance, as we overwrite fields when this is sent over the FFI
    // boundary
    public partial class VecUtf8String
    {
        internal IntPtr _ptr;
        internal ulong _len;
        internal ulong _capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class VecUtf8String : IDisposable
    {
        // An internal helper to create an empty object.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private VecUtf8String() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecUtf8String From(Span<Utf8String> _data)
        {
            var _temp = new Utf8String.Unmanaged[_data.Length];
            for (var i = 0; i < _data.Length; ++i)
            {
                _temp[i] = _data[i].IntoUnmanaged();
            }
            fixed (void* _data_ptr = _temp)
            {
                InteropHelper.interoptopus_vec_create((IntPtr) _data_ptr, (ulong)_data.Length, out var _out);
                return _out.IntoManaged();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecUtf8String Empty()
        {
            InteropHelper.interoptopus_vec_create(IntPtr.Zero, 0, out var _out);
            return _out.IntoManaged();
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get { if (_ptr == IntPtr.Zero) { throw new NullReferenceException(); } else { return (int) _len; } }
        }

        public unsafe Utf8String this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                if (_ptr == IntPtr.Zero) throw new NullReferenceException();
                var _element = Marshal.PtrToStructure<Utf8String.Unmanaged>(new IntPtr(_ptr.ToInt64() + i * sizeof(Utf8String.Unmanaged)));
                return _element.IntoManaged();
            }
        }
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged IntoUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            _ptr = IntPtr.Zero; // Mark this instance as moved.
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged AsUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            InteropHelper.interoptopus_vec_destroy(_unmanaged);
            _ptr = IntPtr.Zero;
            _len = 0;
            _capacity = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "VecUtf8String { ... }";
        }


        public partial class InteropHelper
        {
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_create_17163327104750939811")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_create(IntPtr vec, ulong len, out Unmanaged rval);
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_destroy_13145557392013674812")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_destroy(Unmanaged vec);
        }

        [CustomMarshaller(typeof(VecUtf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _ptr;
            internal ulong _len;
            internal ulong _capacity;
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecUtf8String IntoManaged()
            {
                var rval = new VecUtf8String();
                rval._len = _len;
                rval._capacity = _capacity;
                rval._ptr = _ptr;
                return rval;
            }


        }

        public ref struct Marshaller
        {
            private VecUtf8String _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(VecUtf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(VecUtf8String managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecUtf8String ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }

    }

    public static class VecUtf8StringExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static VecUtf8String IntoVec(this Utf8String[] s) { return VecUtf8String.From(s); }
    }


    // This must be a class because we only ever want to hold on to the
    // same instance, as we overwrite fields when this is sent over the FFI
    // boundary
    public partial class VecVec3f32
    {
        internal IntPtr _ptr;
        internal ulong _len;
        internal ulong _capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class VecVec3f32 : IDisposable
    {
        // An internal helper to create an empty object.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        private VecVec3f32() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecVec3f32 From(Span<Vec3f32> _data)
        {
            var rval = new VecVec3f32();
            fixed (void* _data_ptr = _data)
            {
                InteropHelper.interoptopus_vec_create((IntPtr) _data_ptr, (ulong)_data.Length, out var _out);
                rval._len = _out._len;
                rval._capacity = _out._capacity;
                rval._ptr = _out._ptr;
            }
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe VecVec3f32 Empty()
        {
            InteropHelper.interoptopus_vec_create(IntPtr.Zero, 0, out var _out);
            return _out.IntoManaged();
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get { if (_ptr == IntPtr.Zero) { throw new NullReferenceException(); } else { return (int) _len; } }
        }

        public unsafe Vec3f32 this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                if (_ptr == IntPtr.Zero) throw new NullReferenceException();
                return Marshal.PtrToStructure<Vec3f32>(new IntPtr(_ptr.ToInt64() + i * sizeof(Vec3f32)));
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged IntoUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            _ptr = IntPtr.Zero; // Mark this instance as moved.
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged AsUnmanaged()
        {
            if (_ptr == IntPtr.Zero) throw new NullReferenceException(); // Don't use for serialization if moved already.
            var rval = new Unmanaged();
            rval._len = _len;
            rval._capacity = _capacity;
            rval._ptr = _ptr;
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            InteropHelper.interoptopus_vec_destroy(_unmanaged);
            _ptr = IntPtr.Zero;
            _len = 0;
            _capacity = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public override string ToString()
        {
            return "VecVec3f32 { ... }";
        }


        public partial class InteropHelper
        {
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_create_1781563852271199874")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_create(IntPtr vec, ulong len, out Unmanaged rval);
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_vec_destroy_12107015372467426116")]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            internal static partial long interoptopus_vec_destroy(Unmanaged vec);
        }

        [CustomMarshaller(typeof(VecVec3f32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr _ptr;
            internal ulong _len;
            internal ulong _capacity;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecVec3f32 IntoManaged()
            {
                var rval = new VecVec3f32();
                rval._len = _len;
                rval._capacity = _capacity;
                rval._ptr = _ptr;
                return rval;
            }


        }

        public ref struct Marshaller
        {
            private VecVec3f32 _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(VecVec3f32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(VecVec3f32 managed) { _managed = managed; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged() { return _managed.IntoUnmanaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public VecVec3f32 ToManaged() { return _unmanaged.IntoManaged(); }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() {}
        }
    }

    public static class VecVec3f32Extensions
    {
        public static VecVec3f32 Vec(this Vec3f32[] s) { return VecVec3f32.From(s); }
    }



    public partial class ServiceAsyncBasic : IDisposable
    {
        private IntPtr _context;

        private ServiceAsyncBasic() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceAsyncBasic New()
        {
            var self = new ServiceAsyncBasic();
            self._context = Interop.service_async_basic_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_async_basic_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task Call()
        {
            return Interop.service_async_basic_call(_context);
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceAsyncSleep : IDisposable
    {
        private IntPtr _context;

        private ServiceAsyncSleep() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceAsyncSleep New()
        {
            var self = new ServiceAsyncSleep();
            self._context = Interop.service_async_sleep_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_async_sleep_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task<ulong> ReturnAfterMs(ulong x, ulong ms)
        {
            return Interop.service_async_sleep_return_after_ms(_context, x, ms);
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceAsyncVecString : IDisposable
    {
        private IntPtr _context;

        private ServiceAsyncVecString() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceAsyncVecString New()
        {
            var self = new ServiceAsyncVecString();
            self._context = Interop.service_async_vec_string_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_async_vec_string_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task<Utf8String> HandleString(Utf8String s)
        {
            return Interop.service_async_vec_string_handle_string(_context, s);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task<VecUtf8String> HandleVecString(VecUtf8String s)
        {
            return Interop.service_async_vec_string_handle_vec_string(_context, s);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task<UseString> HandleNestedString(Utf8String s)
        {
            return Interop.service_async_vec_string_handle_nested_string(_context, s);
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceAsyncResult : IDisposable
    {
        private IntPtr _context;

        private ServiceAsyncResult() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceAsyncResult New()
        {
            var self = new ServiceAsyncResult();
            self._context = Interop.service_async_result_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_async_result_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task Success()
        {
            return Interop.service_async_result_success(_context);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task Fail()
        {
            return Interop.service_async_result_fail(_context);
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceAsyncStructs : IDisposable
    {
        private IntPtr _context;

        private ServiceAsyncStructs() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceAsyncStructs New()
        {
            var self = new ServiceAsyncStructs();
            self._context = Interop.service_async_structs_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_async_structs_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Task<NestedArray> ProcessStruct(NestedArray x)
        {
            return Interop.service_async_structs_process_struct(_context, x);
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceBasic : IDisposable
    {
        private IntPtr _context;

        private ServiceBasic() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceBasic New()
        {
            var self = new ServiceBasic();
            self._context = Interop.service_basic_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_basic_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceMain : IDisposable
    {
        private IntPtr _context;

        private ServiceMain() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceMain New(uint x)
        {
            var self = new ServiceMain();
            self._context = Interop.service_main_new(x).AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_main_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceDependent : IDisposable
    {
        private IntPtr _context;

        private ServiceDependent() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceDependent FromMain(IntPtr main)
        {
            var self = new ServiceDependent();
            self._context = Interop.service_dependent_from_main(main).AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_dependent_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public uint Get()
        {
            return Interop.service_dependent_get(_context);
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceResult : IDisposable
    {
        private IntPtr _context;

        private ServiceResult() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceResult New()
        {
            var self = new ServiceResult();
            self._context = Interop.service_result_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_result_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Test()
        {
            Interop.service_result_test(_context).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public uint ResultU32()
        {
            return Interop.service_result_result_u32(_context).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Utf8String ResultString()
        {
            return Interop.service_result_result_string(_context).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public OptionEnumPayload ResultOptionEnum()
        {
            return Interop.service_result_result_option_enum(_context).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public uint ResultSlice(SliceU32 slice, ulong i)
        {
            return Interop.service_result_result_slice(_context, slice, i).AsOk();
        }

        public IntPtr Context => _context;
    }


    /// Some struct we want to expose as a class.
    public partial class ServiceOnPanic : IDisposable
    {
        private IntPtr _context;

        private ServiceOnPanic() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceOnPanic New()
        {
            var self = new ServiceOnPanic();
            self._context = Interop.service_on_panic_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_on_panic_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        /// Methods returning a Result<(), _> are the default and do not
        /// need annotations.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void ReturnResult(uint anon1)
        {
            Interop.service_on_panic_return_result(_context, anon1).AsOk();
        }

        /// Methods returning a value need an `on_panic` annotation.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public uint ReturnDefaultValue(uint x)
        {
            return Interop.service_on_panic_return_default_value(_context, x);
        }

        /// This function has no panic safeguards. It will be a bit faster to
        /// call, but if it panics your host app will abort.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IntPtr ReturnUbOnPanic()
        {
            return Interop.service_on_panic_return_ub_on_panic(_context);
        }

        public IntPtr Context => _context;
    }


    /// Some struct we want to expose as a class.
    public partial class ServiceCallbacks : IDisposable
    {
        private IntPtr _context;

        private ServiceCallbacks() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceCallbacks New()
        {
            var self = new ServiceCallbacks();
            self._context = Interop.service_callbacks_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_callbacks_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackSimple(MyCallback callback)
        {
            Interop.service_callbacks_callback_simple(_context, callback).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackSimple(MyCallbackDelegate callback)
        {
            Interop.service_callbacks_callback_simple(_context, callback).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackFfiReturn(SumDelegateReturn callback)
        {
            Interop.service_callbacks_callback_ffi_return(_context, callback).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackFfiReturn(SumDelegateReturnDelegate callback)
        {
            Interop.service_callbacks_callback_ffi_return(_context, callback).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackWithSlice(SumDelegateReturn callback, SliceI32 input)
        {
            Interop.service_callbacks_callback_with_slice(_context, callback, input).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackWithSlice(SumDelegateReturnDelegate callback, SliceI32 input)
        {
            Interop.service_callbacks_callback_with_slice(_context, callback, input).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void SetDelegateTable(CallbackTable table)
        {
            Interop.service_callbacks_set_delegate_table(_context, table);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void InvokeDelegates()
        {
            Interop.service_callbacks_invoke_delegates(_context).AsOk();
        }

        public IntPtr Context => _context;
    }


    public partial class ServiceIgnoringMethods : IDisposable
    {
        private IntPtr _context;

        private ServiceIgnoringMethods() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceIgnoringMethods New()
        {
            var self = new ServiceIgnoringMethods();
            self._context = Interop.service_ignoring_methods_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_ignoring_methods_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        public IntPtr Context => _context;
    }


    /// Some struct we want to expose as a class.
    public partial class ServiceMultipleCtors : IDisposable
    {
        private IntPtr _context;

        private ServiceMultipleCtors() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceMultipleCtors NewWith(uint some_value)
        {
            var self = new ServiceMultipleCtors();
            self._context = Interop.service_multiple_ctors_new_with(some_value).AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceMultipleCtors NewWithout()
        {
            var self = new ServiceMultipleCtors();
            self._context = Interop.service_multiple_ctors_new_without().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceMultipleCtors NewWithString([MarshalAs(UnmanagedType.LPStr)] string anon0)
        {
            var self = new ServiceMultipleCtors();
            self._context = Interop.service_multiple_ctors_new_with_string(anon0).AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceMultipleCtors NewFailing(byte some_value)
        {
            var self = new ServiceMultipleCtors();
            self._context = Interop.service_multiple_ctors_new_failing(some_value).AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_multiple_ctors_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        public IntPtr Context => _context;
    }


    /// Some struct we want to expose as a class.
    public partial class ServiceVariousSlices : IDisposable
    {
        private IntPtr _context;

        private ServiceVariousSlices() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceVariousSlices New()
        {
            var self = new ServiceVariousSlices();
            self._context = Interop.service_various_slices_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_various_slices_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public byte MutSelf(SliceU8 slice)
        {
            return Interop.service_various_slices_mut_self(_context, slice);
        }

        /// Single line.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void MutSelfVoid(SliceBool slice)
        {
            Interop.service_various_slices_mut_self_void(_context, slice);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public byte MutSelfRef(ref byte x, ref byte y)
        {
            return Interop.service_various_slices_mut_self_ref(_context, ref x, ref y);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public byte MutSelfRefSlice(ref byte x, ref byte y, SliceU8 slice)
        {
            return Interop.service_various_slices_mut_self_ref_slice(_context, ref x, ref y, slice);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public byte MutSelfRefSliceLimited(ref byte x, ref byte y, SliceU8 slice, SliceU8 slice2)
        {
            return Interop.service_various_slices_mut_self_ref_slice_limited(_context, ref x, ref y, slice, slice2);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void MutSelfFfiError(SliceMutU8 slice)
        {
            Interop.service_various_slices_mut_self_ffi_error(_context, slice).AsOk();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void MutSelfNoError(SliceMutU8 slice)
        {
            Interop.service_various_slices_mut_self_no_error(_context, slice).AsOk();
        }

        /// Warning, you _must_ discard the returned slice object before calling into this service
        /// again, as otherwise undefined behavior might happen.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public SliceU32 ReturnSlice()
        {
            return Interop.service_various_slices_return_slice(_context);
        }

        /// Warning, you _must_ discard the returned slice object before calling into this service
        /// again, as otherwise undefined behavior might happen.
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public SliceMutU32 ReturnSliceMut()
        {
            return Interop.service_various_slices_return_slice_mut(_context);
        }

        public IntPtr Context => _context;
    }


    /// Some struct we want to expose as a class.
    public partial class ServiceStrings : IDisposable
    {
        private IntPtr _context;

        private ServiceStrings() {}

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceStrings New()
        {
            var self = new ServiceStrings();
            self._context = Interop.service_strings_new().AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static ServiceStrings NewString(Utf8String x)
        {
            var self = new ServiceStrings();
            self._context = Interop.service_strings_new_string(x).AsOk();
            return self;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            Interop.service_strings_destroy(_context).AsOk();
            _context = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void PassCstr([MarshalAs(UnmanagedType.LPStr)] string anon1)
        {
            Interop.service_strings_pass_cstr(_context, anon1);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public IntPtr ReturnCstr()
        {
            return Interop.service_strings_return_cstr(_context);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackString(Utf8String s, StringCallback cb)
        {
            Interop.service_strings_callback_string(_context, s, cb);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void CallbackString(Utf8String s, StringCallbackDelegate cb)
        {
            Interop.service_strings_callback_string(_context, s, cb);
        }

        public IntPtr Context => _context;
    }




    public class EnumException() : InteropException($"Enum variant mismatch.")  { }

    public class EnumException<T>(T t) : InteropException($"Enum variant mismatch.")
    {
        public T Value { get; } = t;
    }

    public class InteropException(string text) : Exception(text) { }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void AsyncHelperNative(IntPtr data, IntPtr callback_data);
    public delegate void AsyncHelperDelegate(IntPtr data);

    public partial struct AsyncHelper
    {
        private AsyncHelperDelegate _managed;
        private AsyncHelperNative _native;
        private IntPtr _ptr;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct AsyncHelper : IDisposable
    {
        public AsyncHelper() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public AsyncHelper(AsyncHelperDelegate managed)
        {
            _managed = managed;
            _native = Call;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        void Call(IntPtr data, IntPtr _)
        {
            _managed(data);
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            Marshal.FreeHGlobal(_ptr);
            _ptr = IntPtr.Zero;
        }

        [CustomMarshaller(typeof(AsyncHelper), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr Callback;
            internal IntPtr Data;
        }

        public ref struct Marshaller
        {
            private AsyncHelper _managed;
            private Unmanaged _unmanaged;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(AsyncHelper managed) { _managed = managed; }
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Callback = _managed._ptr;
                _unmanaged.Data = IntPtr.Zero;
                return _unmanaged;
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public AsyncHelper ToManaged()
            {
                _managed = new AsyncHelper();
                _managed._ptr = _unmanaged.Callback;
                return _managed;
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() { }
        }
    }

    public delegate void AsyncCallbackCommon(IntPtr data, IntPtr callback_data);

    [StructLayout(LayoutKind.Sequential)]
    public partial struct AsyncCallbackCommonNative
    {
        internal IntPtr _ptr;
        internal IntPtr _ts;
    }
    public partial class Utf8String
    {
        IntPtr _ptr;
        ulong _len;
        ulong _capacity;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class Utf8String : IDisposable
    {
        private Utf8String() { }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Utf8String From(string s)
        {
            var rval = new Utf8String();
            var source = s.AsSpan();
            Span<byte> utf8Bytes = stackalloc byte[Encoding.UTF8.GetByteCount(source)];
            var len = Encoding.UTF8.GetBytes(source, utf8Bytes);

            fixed (byte* p = utf8Bytes)
            {
                InteropHelper.interoptopus_string_create((IntPtr)p, (ulong)len, out var native);
                rval._ptr = native._ptr;
                rval._len = native._len;
                rval._capacity = native._capacity;
            }

            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static unsafe Utf8String Empty()
        {
            InteropHelper.interoptopus_string_create(IntPtr.Zero, 0, out var _out);
            return _out.IntoManaged();
        }


        public unsafe string String
        {
            get
            {
                var span = new ReadOnlySpan<byte>((byte*)_ptr, (int)_len);
                var s = Encoding.UTF8.GetString(span);
                return s;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public string IntoString()
        {
            var rval = String;
            Dispose();
            return rval;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            InteropHelper.interoptopus_string_destroy(_unmanaged);
            _ptr = IntPtr.Zero;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Utf8String Clone()
        {
            var _new = new Unmanaged();
            var _this = AsUnmanaged();
            InteropHelper.interoptopus_string_clone(ref _this, ref _new);
            return _new.IntoManaged();
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged IntoUnmanaged()
        {
            if (_ptr == IntPtr.Zero) { throw new Exception(); }
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            _ptr = IntPtr.Zero;
            return _unmanaged;
        }

        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public Unmanaged AsUnmanaged()
        {
            var _unmanaged = new Unmanaged();
            _unmanaged._ptr = _ptr;
            _unmanaged._len = _len;
            _unmanaged._capacity = _capacity;
            return _unmanaged;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr _ptr;
            public ulong _len;
            public ulong _capacity;

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Utf8String IntoManaged()
            {
                var _managed = new Utf8String();
                _managed._ptr = _ptr;
                _managed._len = _len;
                _managed._capacity = _capacity;
                return _managed;
            }

        }

        public partial class InteropHelper
        {
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_create")]
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            public static partial long interoptopus_string_create(IntPtr utf8, ulong len, out Unmanaged rval);

            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_destroy")]
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            public static partial long interoptopus_string_destroy(Unmanaged utf8);

            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_clone")]
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            [DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory)]
            public static partial long interoptopus_string_clone(ref Unmanaged orig, ref Unmanaged cloned);
        }

        [CustomMarshaller(typeof(Utf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private Utf8String _managed; // Used when converting managed -> unmanaged
            private Unmanaged _unmanaged; // Used when converting unmanaged -> managed

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Utf8String managed) { _managed = managed; }
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromManaged(Utf8String managed) { _managed = managed; }
            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public unsafe Unmanaged ToUnmanaged()
            {
                return _managed.IntoUnmanaged();
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public unsafe Utf8String ToManaged()
            {
                return _unmanaged.IntoManaged();
            }

            [MethodImpl(MethodImplOptions.AggressiveOptimization)]
            public void Free() { }
        }
    }

    public static class StringExtensions
    {
        public static Utf8String Utf8(this string s) { return Utf8String.From(s); }
    }

    public partial class WireInterop {
        [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_wire_destroy")]
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public static partial void interoptopus_wire_destroy(IntPtr data, int len, int capacity);

        #region Serialization Helpers
        #nullable enable

        public static void SerializeString(BinaryWriter writer, string value)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            var bytes = Encoding.UTF8.GetBytes(value);
            writer.Write((ulong)bytes.Length);
            writer.Write(bytes);
        }

        public static string DeserializeString(BinaryReader reader)
        {
            var length = reader.ReadUInt64();
            if (length == 0)
                return string.Empty;

            var bytes = reader.ReadBytes((int)length);
            return Encoding.UTF8.GetString(bytes);
        }

        public static void SerializeVecOfByte(BinaryWriter writer, byte[] vec)
        {
            writer.Write((ulong)vec.Length);
            writer.Write(vec);
        }

        public static void SerializeVec<T>(BinaryWriter writer, IList<T> value, Action<BinaryWriter, T> serializeItem)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            writer.Write((ulong)value.Count);
            foreach (var item in value)
            {
                serializeItem(writer, item);
            }
        }

        public static byte[] DeserializeVecOfByte(BinaryReader reader)
        {
            var length = reader.ReadUInt64();
            return reader.ReadBytes((int)length);
        }

        public static T[] DeserializeVec<T>(BinaryReader reader, Func<BinaryReader, T> deserializeItem)
        {
            var length = reader.ReadUInt64();
            var result = new T[(int)length];

            for (ulong i = 0; i < length; i++)
            {
                result[i] = deserializeItem(reader);
            }

            return result;
        }

        public static void SerializeMap<K,V>(BinaryWriter writer, IDictionary<K,V> value, Action<BinaryWriter, K> serializeKey, Action<BinaryWriter, V> serializeValue)
        {
            if (value == null)
            {
                writer.Write((ulong)0);
                return;
            }

            writer.Write((ulong)value.Count);
            foreach (var item in value)
            {
                serializeKey(writer, item.Key);
                serializeValue(writer, item.Value);
            }
        }

        public static Dictionary<K,V> DeserializeMap<K,V>(BinaryReader reader, Func<BinaryReader, K> deserializeKey, Func<BinaryReader, V> deserializeValue)
        {
            var length = reader.ReadUInt64();
            var result = new Dictionary<K,V>((int)length);

            for (ulong i = 0; i < length; i++)
            {
                var k = deserializeKey(reader);
                var v = deserializeValue(reader);
                result.Add(k, v);
            }

            return result;
        }

        public static void SerializeOptional<T>(BinaryWriter writer, T? value, Action<BinaryWriter, T> serializeItem)
        {
            if (value != null)
            {
                writer.Write((byte)1);
                serializeItem(writer, value);
            }
            else
            {
                writer.Write((byte)0);
            }
        }

        #nullable enable
        public static T? DeserializeOptional<T>(BinaryReader reader, Func<BinaryReader, T> deserializeValue)
        {
            var hasValue = reader.ReadByte() != 0;
            if (hasValue)
            {
                return deserializeValue(reader);
            }
            return default;
        }
        #nullable restore

        public static T? DeserializeEnum<T>(BinaryReader reader) where T: System.Enum
        {
            var discriminant = reader.ReadInt32();
            if (Enum.IsDefined(typeof(T), discriminant))
            {
                return (T)Enum.ToObject(typeof(T), discriminant);
            }
            return default(T);
        }

        public static int CalculateVariableMapSize<K,V>(IDictionary<K,V> value, Func<K, int> calculateKeySize, Func<V, int> calculateValueSize)
        {
            int size = Marshal.SizeOf<ulong>(); // length field
            if (value == null) return size;

            foreach (var item in value)
            {
                size +=
                    calculateKeySize(item.Key)
                    + calculateValueSize(item.Value);}
            return size;
        }

        /// This method is called only for non-primitive inner types which require size calculations.
        public static int CalculateVariableVecSize<T>(IList<T> value, Func<T, int> calculateItemSize)
        {
            int size = Marshal.SizeOf<ulong>(); // length field
            if (value == null) return size;foreach (var item in value)
            {
                size += calculateItemSize(item);
            }
            return size;
        }

        #nullable restore
        #endregion
    }

    public static class SerdeStringExtensions
    {
        public static void Serialize(this String value, BinaryWriter writer) {
            WireInterop.SerializeString(writer, value);
        }

        public static String DeserializeString(BinaryReader reader) {
            return WireInterop.DeserializeString(reader);
        }

        public static int CalculateSize(String value) {
            return Marshal.SizeOf<ulong>() + System.Text.Encoding.UTF8.GetByteCount(value ?? "");
        }
    }
}
